#+TITLE: 
#+AUTHOR: Tais Bellini

#+STARTUP: overview indent
#+LANGUAGE: en
#+OPTIONS: H:3 creator:nil timestamp:nil skip:nil toc:nil num:t ^:nil ~:~
#+OPTIONS: author:nil title:nil date:nil
#+TAGS: noexport(n) deprecated(d) ignore(i)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+LATEX_CLASS: iiufrgs
#+LATEX_CLASS_OPTIONS: [times,cic,tc,english]
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{subfigure}
#+LATEX_HEADER: \usepackage{tabulary}
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{algorithmic}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \newcommand{\prettysmall}{\fontsize{6.5}{6.5}\selectfont}
#+LATEX_HEADER: \newcommand{\prettysmallbis}{\fontsize{7}{7}\selectfont}
#+LATEX_HEADER: \newcommand{\mtilde}{~}

#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{palatino}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{cleveref}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage[normalem]{ulem}
#+LATEX_HEADER: \usepackage{xspace}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \graphicspath{{img/}{img/final/}}
#+LATEX_HEADER: \hypersetup{hidelinks = true}

#+LATEX_HEADER: \newcommand{\review}[1]{\textcolor[rgb]{1,0,0}{[Lucas: #1]}}
#+LATEX_HEADER: \newcommand{\lucas}[1]{\textcolor[rgb]{0.2,0.2,0.7}{[Lucas: #1]}}
#+LATEX_HEADER: \input{configuration.tex}


#+BEGIN_LaTeX
\title{TCC da Tais}
\author{Loureiro Bellini}{Tais}
\advisor[Prof.~Dr.]{Mello Schnorr}{Lucas}

\date{Junho}{2016}
\location{Porto Alegre}{RS}

% \renewcommand{\nominataReit}{Prof\textsuperscript{a}.~Wrana Maria Panizzi}
% \renewcommand{\nominataReitname}{Reitora}
% \renewcommand{\nominataPRE}{Prof.~Jos{\'e} Carlos Ferraz Hennemann}
% \renewcommand{\nominataPREname}{Pr{\'o}-Reitor de Ensino}
% \renewcommand{\nominataPRAPG}{Prof\textsuperscript{a}.~Joc{\'e}lia Grazia}
% \renewcommand{\nominataPRAPGname}{Pr{\'o}-Reitora Adjunta de P{\'o}s-Gradua{\c{c}}{\~a}o}
% \renewcommand{\nominataDir}{Prof.~Philippe Olivier Alexandre Navaux}
% \renewcommand{\nominataDirname}{Diretor do Instituto de Inform{\'a}tica}
% \renewcommand{\nominataCoord}{Prof.~Carlos Alberto Heuser}
% \renewcommand{\nominataCoordname}{Coordenador do PPGC}
% \renewcommand{\nominataBibchefe}{Beatriz Regina Bastos Haro}
% \renewcommand{\nominataBibchefename}{Bibliotec{\'a}ria-chefe do Instituto de Inform{\'a}tica}
% \renewcommand{\nominataChefeINA}{Prof.~Jos{\'e} Valdeni de Lima}
% \renewcommand{\nominataChefeINAname}{Chefe do \deptINA}
% \renewcommand{\nominataChefeINT}{Prof.~Leila Ribeiro}
% \renewcommand{\nominataChefeINTname}{Chefe do \deptINT}


% \keyword{formatação eletrônica de documentos}
% \keyword{\LaTeX}
% \keyword{ABNT}
% \keyword{UFRGS}



\maketitle



#+END_LaTeX

                                                      
# #+BEGIN_LaTeX
# \begin{abstract}
# #+END_LaTeX


# #+BEGIN_LaTeX
# \end{abstract}
# #+END_LaTeX


* Configuring Emacs to correctly export to PDF			   :noexport:

Org mode is configured by default to export only the base classes.

See for details:
+ http://orgmode.org/worg/org-tutorials/org-latex-export.html

Execute the following code (with C-c C-c) prior to export this file to PDF.

#+BEGIN_SRC emacs-lisp :results silent :exports none
(add-to-list 'org-latex-classes
             '("iiufrgs"
               "\\documentclass{iiufrgs}"
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC
* 2016-03-18 First entry (proper emacs configuration file)   :noexport:Lucas:

I recommend you use Arnaud's emacs configuration file, available here:
+ http://mescal.imag.fr/membres/arnaud.legrand/misc/init.php

Download the file =init.org=:

#+begin_src sh :results output :session :exports both
wget http://mescal.imag.fr/membres/arnaud.legrand/misc/init.org
#+end_src

#+RESULTS:

* 2016-04-29 How to compile with _bibtex_ entries              :Lucas:noexport:

Do as follows:

1. Export as usual to latex
2. Then, type in the terminal
   #+begin_src sh :results output :session :exports both
   pdflatex Dissertation.tex
   bibtex Dissertation
   pdflatex Dissertation.tex
   pdflatex Dissertation.tex
   #+end_src

* Introduction
Observation of program behavior is particularly important in High
Performance Computing since it enables an accurate performance
analysis. A very common method of evaluation is registering program
events in trace files that work as a log, so, whenever a relevant
event happens, it will be logged in the trace file with the proper
information. Then, these traces are replayed in simulation combining
information that is spread across multiple events deriving new and
richer entities \cite{XXX}. This event processing is usually done once
and discarded, which can be very inconvenient considering that some
trace files are very large. Therefore, it would be interesting to save
these entities for further analysis.

In this context of performance analysis, a common tool used is the
Pajé Trace Simulator \cite{kergommeaux2000paje}, an open source
project that reads trace files in a specific format, the Pajé Trace
File Format \cite{pajetracefile}, and processes five types of
entities: Containers, States, Events, Variables and Links. These
concepts represent basic structures of computer programs executed in
parallel or distributed systems, such as processes, threads, network
links, hardware counters and so on. As a base for the implementation
of this proposal, the new generation of Pajé, PajeNG \cite{pajeng},
was used. Details of PajeNG, the types of entities and the Pajé File
Format will be presented in Chapter \ref{chapter.paje}. Although it
has a visualization functionality, we will focus on the simulation
part of the Pajé implementation in this project. The most commonly
used tool of PajeNG is the Pajé Dump (=pj_dump=) \cite{XXX}, that
dumps to the standard output all information regarding entities
created throughout the simulation.

There are at least three problems with the current implementation of
Pajé: little extensibility, lack of partial outcomes and impermanent
results. The original Pajé and, consequently, its next generation were
idealized and built in an extensible way, that could be easily
expanded based on the user's needs. Although the implementation is
very modular, it is necessary to write a full component for Pajé,
which is a complex thing because it implies in understanding the
internal objects, class hierarchy, protocol, and so on. Until now,
very few people have actually extended this tool. Throughout the
simulation, the Pajé tool creates entities according to the events
listed in the trace file, saving each one of them in memory to dump
everything at once in the end. Since some trace files can be very
large (over 1 Gigabyte), it may take a while for the results to be
printed out. Besides not being able to have a partial view of already
simulated entities, the user won't have records of the results between
executions for different files unless he specifies a destination for
it himself. To address these issues, an extensible trace files
simulator, Aiyra, was developed in Java.

The objective of this proposal is to allow the performance analyst to
change the simulator behavior when a new entity is detected. Thus, the
partial results can be immediately presented to the user, or saved in
a database, or even discarded if not relevant. This extensibility is
implemented through the concept of plugins that are attached to the
simulator in specific and important points where the trace events are
combined. This main objective solves the lack of extensibility
problem. Once the simulator allows the immediate manipulation of the 
entities, the other two issues can be easily addressed with
extensions. Hence, the secondary objectives of the project are the 
creation of plugins to dump partial data that has just been simulated 
and to make the results permanent.

For the validation of the extensible trace files simulator, two
plugins were implemented: Paje Dump Plugin and Paje Insert Database
Plugin. The first one plays the same roll as the original Paje Dump
tool in the Paje new generation, with the difference that the entities
are dumped at the moment they are completed. The second one inserts
all the data in a relational database. A specific schema for the Pajé
Format was designed and will be presented in Chapter
\ref{chapter.plugins}.  A performance analysis was developed to
compare Aiyra against the previous one. It is worth highlighting that
the new simulator had better performance results with bigger files
(over 120 Megabytes), that being possibly attributed to the fact that
it discards from memory entities that will no longer be
used. Additionally, the Pajé Insert Database plugin was evaluated
comparing its different possibilities of usage. In this investigation,
we varied the frequency of the insertions in the database by grouping
queries in memory until it had a specific size to insert. The
objective of this test was to understand the impact of an access to a
database in the performance of the program. Likewise, the usage of the
memory was also examined to determine the best balance between
execution time and memory management. As we will see in Chapter 6, the
memory usage had more impact in the performance than the accesses to
the database themselves, probably due to the Garbage Collector
mechanism used by Java.

This document is organized as follows. Chapter
\ref{chapter.basic_concepts} provides the basic concepts of the
technologies used throughout the project.  Chapter \ref{chapter.paje}
gives an overview of the existing simulator for the Pajé format and
the problems with this current implementation. Chapter
\ref{chapter.aiyra} describes the details of the extensible simulator
developed in Java and Chapter \ref{chapter.plugins} characterize the
plugins developed. Chapter \ref{chapter.performance} presents a
performance analysis of the Pajé Insert Database Plugin and a
comparison between Aiyra and PajeNG.  The conclusion and final
considerations are expressed in Chapter \ref{chapter.conclusion}.

* Basic Concepts
\label{chapter.basic_concepts}

This chapter describes the basic notions of the concepts and
technologies used to develop this project. They contribute to the
understanding of our work. It is structured in five topics: the Java
Compiler Compiler (JavaCC), the Java Database Connectivity (JDBC) API
in the MySQL context, a brief description about the construction of
conceptual and logical database schemas, an overview about
experimental design, and the R language in the experimental design
context.

** The Java Compiler Compiler (JavaCC) tool
\label{section.javacc}

The Java Compiler Compiler (JavaCC) is a scanner and parser generator
configured with a set of regular expressions describing the tokens of
a language and a grammar using these tokens. As output, it generates a
lexical and syntax parser in the Java language. The lexical code
separates the input file into tokens; the parser code is responsible
for the syntax analysis.

What differentiates JavaCC from other parser generators that exist for
the Java language is that it creates source code in Java. This
facilitates the understanding and eliminates the need of having
dependencies in the code. JavaCC has also shown itself to have a much
better performance than other tools such as Another Tool For Language
Recognition (ANTLR), that requires a runtime library
\cite{javaccversusantlr}. ANTLR was our first choice of parser
generator, but it was soon discarded due to its very low performance.

JavaCC can be downloaded, unzipped and added to the PATH. It also has
a plugin for Eclipse. Figure \ref{fig.javaccex} exemplifies the flow
in JavaCC. Once installed, JavaCC processes your grammar defined in a file
with extension =.jj= using the command =javacc=. The whole grammar
is kept in this file and it is the only file that needs to be
modified. It is also possible to add Java code that has to be executed
during the parsing.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{How JavaCC works}
\centering
\includegraphics[width=\linewidth]{./img/javaccex.pdf}
\label{fig.javaccex}
\end{figure}
#+END_LaTeX

_Comments_:
- Missing figure, can't give my opinion on it

In Figure \ref{fig.javaccex} we can see an example of the processing
of a file named *MyGrammar.jj*, which results in seven files: the
parser in *MyGrammar.java*; the lexical analyser in
*MyGrammarTokenManager.java* and some useful constants in
*MyGrammarConstants.java*.  The other four files generated:
*Token.java*, *TokenMgrError.java*, *SimpleCharStream.java* and
*ParseException.java* are boilerplate files that can be reused within
parsers and are not affected by the grammar itself.  The corresponding
Java source code for the scanner and parser can be compiled as usual
with =javac=.

** JDBC and MySQL

The Java Database Connectivity (JDBC) API is a standard for
connectivity between Java and a range of relational databases
\cite{jdbc}. It comprises methods to query and update data, enabling
the Java language to interact with several Database Management Systems
(DBMS) in a standard manner. This API facilitates the migration from
one database tool to another and unbounds your application from a
DBMS.

The JDBC architecture, depicted in Figure \ref{fig.jdbcex}, consists
in two layers: JDBC API and JDBC Driver API. JDBC can support multiple
heterogeneous databeses \cite{jdbctut} by using drivers connected to
them. In the example of Figure \ref{fig.jdbcex}, we have an
application communicating with three different databases.  The JDBC
Driver API manages these drivers to ensure that the correct one is
being used. The JDBC API layer, in turn, administrates the
communication between the application and the driver manager. The JDBC
API consists in classes and interfaces, such as *DriverManager*, which
makes a connection between requests from the application and the
proper database driver; *Connection*, containing all the methods
necessary to contact the database; *Statement*, that creates objects
that will be submited to the database; and *ResultSet*, where the
retrieved objects are placed.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Architecture of JDBC. [Inspired in \cite{jdbctut}]}
\centering
\includegraphics[width=\linewidth]{./img/jdbcex.pdf}
\label{fig.jdbcex}
\end{figure}
#+END_LaTeX

Among the possible DBMS that can be used in a Java application using
JDBC is the MySQL system, one of the most important open-source DBMS
in the market. It has been developed by Oracle and uses SQL language
as interface. To enable the use of MySQL with Java, Oracle provides a
driver for JDBC, as well as a native C library to allow developers to
embed SQL commands directly in the application's code.


** Entity-Relationship and Relational Models
\label{subsection.er_relational}

An Entity-Relationship (ER) model defines a database in a conceptual
view \cite{heuser}. This model can be represented by an ER Diagram
(ERD) and can be denoted by *schema*. It is based in the notion of
*entities*, which can be real-world objects that are easily
identifiable \cite{ertutorial}, and the *relationship* between
them. Figure \ref{fig.ermodelex} exemplifies a schema of a school
system where the people and places involved are represented. The
entities have a set of attributes, where one or more are defined as
the *identifier*, which uniquely identify an object of that entity. It
is also possible for a relationship to have attributes, like the
*address* attribute in Figure \ref{fig.ermodelex}. Besides, an entity
can derive other more specialized entities, which is called
*specialization*.

A relationship between entities *A* and *B* can have one of the
following patterns: *one-to-one*, where an object of the entity A can
be associated to only one of type B and vice versa; *one-to-many*,
which means that an instance of the entity A can be associated to more
than one entities of type B, but B entities can only relate to at most
one of type A; *many-to-many*, where one object from the A entity can
be associated to more than one entities of type B and vice
versa. These characteristics also apply to self-referencing relations,
where there is a relationship of an entity with itself. Besides, a
connection can be an *identifying relationship*, which means that the
relationship identifies an object. In Figure \ref{fig.ermodelex} we
can see the example of the relationship between a *City* and a
*State*, where we define that a state can have more than one city,
while a city belongs to only one state. Also, the state identifies a
city along with its name, since there can be other cities with the
same name but in different states. In these cases the entity is called
a *weak entity*.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Example of ER Model}
\centering
\includegraphics[width=\linewidth]{./img/ermodelex.pdf}
\label{fig.ermodelex}
\end{figure}
#+END_LaTeX

The ER Model is an overview of the structure of a database. To evolve
to the implementation, a translation to a Relational Model must be
performed. The ER model is a conceptual description of the database,
while the relational model is a logical representation
\cite{heuser}. Relational databases are based in the concept of
*tables* \cite{relationalmodel}, thus, the terminology used in this
step involves *tables*, *rows* (or *tuples*) and *columns*. The
identifier is called *primary key*. There is a set of rules to make
this translation, although sometimes it is necessary to adapt the
schema based on the user's needs.

The *entities* of the ER model become *tables* in the relational
model, while its attributes become the *columns* of the tables. Each
instance of an entity is a row and its identifier can be one or more
columns that compose the *primary key*. When there is an identifying
relationship, the weak entity attaches the identifier of the other
entity to its own primary key. In Figure \ref{fig.ermodelex}, the
*City* table has two columns as primary key: *stateName* and
*cityName*. A *one-to-one* relationship generates a merge of both
tables involved. *One-to-many* links adds an attribute in one of the
tables. The entity that can only be related to one of the instances of
the other receives the attribute, which is called *foreign key*. It
also absorbs the attributes of the relationship. In the example of
figure \ref{fig.ermodelex}, the table referencing the *School* entity
would have the *stateName* and *cityName* as foreign keys and
*address* as attribute. The foreign key is what preserves the link
between two entities. *Many-to-many* relationships have to be
represented by a separate table with the primary keys of both entities
involved, which also work as foreign keys. In our illustration, the
relationship between *Grade* and *Student* would become a table, with
*studentId* and *gradeId* as primary and foreign keys.

The translation of specializations can be made in two ways: one single
table for all of the hierarchy, where the primary key would be the
identifier of the most generic entity and there would be optional
columns; and one table for each specialized entity, where all of them
would have the identifier of the most generic entity composing the
primary key. In Figure \ref{fig.ermodelex}, the first case would
generate a single *Person* table, with *personId* as primary key and
*name*, *phone*, *studentId*, *course* and *salary* as attributes. In
the second option, *Student* and *Teacher* become tables, with
*personId* composing their primary key.

** Experimental Design

Experimental design, in the context of performance analysis, aims to
define a minimum number of experiments that collects the maximum
information necessary \cite{jain}. It also targets random variations
that could affect the results, guaranteeing that the number of tests
executed and the error margin calculated is sufficient to avoid
misleading conclusions.

There is a specific terminology used in experimental design. The term
*Response Variable* is the outcome of an experiment; *Factors* are all
of the variables that can have several different values affecting the
response variable, and *Levels* are the possible values that a factor
can assume. Also, the *Primary Factors* are the factors that need to
be quantified, *Secondary Factors* are the factors whose impacts in
the performance are irrelevant for the analysis, *Replication* is the
number of repetition of all or some experiments and *Design* is the
specification of total number of experiments based on factor level
combination and number of replications for each experiment. The
*Experimental Unit* is the entity used for the experiment, which could
be a computer, for example, and *Interaction* is when the levels of a
fator affect the results of other factor.

There are several types of experimental design modeling. One of them
is the full factorial design, which consists in evaluating every
possible combination at all levels of all factors. With this type of
design, it is possible to measure factors with multiple numbers of
levels. The advantage of this model is that every possible combination
is measured, generating richer results. However, depending on the
number of factors, levels and replications, it may generate too many
experiments, which can cost a lot of time. Therefore, when using this
technique, it is important to weight the relevance of each factor and
level to generate an appropriate and accurate design. To calculate the
total size of the sample you multiply the numbers of levels of the
factors and the number of replications. For example, a design with a
three-level factor, a two-level factor and 20 replications would have
120 experiments (the result of $3*2*20$).

When there are too many factors and levels, it may not be possible to
use the full factorial design. In these cases, one can use a
fractional factorial design, which covers just a fraction of the full
factorial design. In this type of experiment, a carefully chosen
subset of factors and levels is taken into consideration, based on the
most important features the analyser wants to test. Although it saves
time and expenses, the results provide less information.


** The R language

R is a language for statistical computing and graphics generation. It
can be very easily extended, by creating and using packages. With R,
it is possible to create full factorial or fractional designs using
the *DoE.base* package. It contains the class *design* with several
accessor functions to create different types of design. One particular
important function is the *fac.design*, which creates full factorial
designs with an arbitrary numbers of levels. The function receives
several arguments, including number of factors, levels and
replication. The usage of the function is the following:
#+BEGIN_LaTeX
\begin{lstlisting}
require(DoE.base);
fac.design(
  nfactors=2,
  replications=30,
  repeat.only=FALSE,
  blocks=1,
  randomize=TRUE,
  seed=10373,
  nlevels=(3,6),
  factor.names= list(
                input=c("small", "medium", "big"),
                batch=c("A", "B", "C", "D", "E", "F")));
\end{lstlisting}
#+END_LaTeX
where =nfactors= represents the number of factors, *replications* is
the number of replications, *repeat.only* tells if the replications of
each run are grouped together, *blocks* is a prime-number telling in
how many blocks the experiment is subdivided, *randomize* informs the
design is randomized, *seed* is the optional seed for the
randomization, *nlevels* is a vector with the number of levels for
each factor and *factor.names*: a list of vectors with factor levels.
This example is one of the designs used for the performance evaluation
in Chapter \ref{chapter.performance}.


* Pajé Visualization Tool - PajeNG 
\label{chapter.paje}

The Pajé Visualization Tool is an implementation to display the
execution behavior of parallel and distributed programs. It reads
information from trace files that describe the important events during
the execution of a program and replays them through simulation.  It
has been developed to simulate trace files in the Pajé Trace File
Format, thus, it is important to understand how the Pajé trace files
are composed. Section \ref{section.pajeformat} describes this format
and all entity types it contains. The next section describes the new
generation of the Pajé Visualization Tool, the PajeNG, focusing on the
*libpaje* module, which is where the core simulation is performed.
 
** Pajé Trace File Format
\label{section.pajeformat}

_Comments_
- Remove the first two sentences.

This section gives an overview of the Pajé Trace File Format. Its
complete description is in Appendix \ref{ap.pajeformat}. The Pajé
Trace File Format \cite{pajetracefile} is a textual and generic
pattern that describes the behaviour of parallel and distributed
programs. The Pajé format describes five types of entities:
containers, states, events, variables and links. Each entity is always
associated to a container, even the containers themselves. A
*container* can be any hardware or software entity, such as a
processor, a thread, a network link, etc. It is the only Pajé object
that holds other objects, including containers, which makes it the
main component to define a type hierarchy. A *state* is used to
describe periods of time where a container stays at the same state,
like a thread that is blocked, for example. It always has a beginning
and an ending timestamps. An *event* has only one timestamp, and can
be anything noteworthy to be uniquely identified. A *variable* entity
represents the progression of a variable's value along time. It is
represented by an object with a value and two timestamps, beginning
and end, indicating how long the variable had that specific value. A
*link* represents a relationship between two containers, such as a
communication between processes. It contains two timestamps specifying
the beginning and the end of the communication. A Pajé trace file is
divided in two segments: event definition and timestamped events. A
brief description of these sections is provided below. For details and
an example of an event definition, as well as a full list of events
refer to Appendix \ref{ap.pajeformat}.

*** Header section: events definition

The first part of a trace file describes all of the possible events of
the trace. This part is composed by a block where the first line
contains the name of the event, like *PajeDefineContainerType*, for
example, followed by a unique identifier. The identifier is an integer
and will be used later by the events to determine the type of event in
question. After, there is a set of fields, one in each line. Each
field comprises a name, and a type. The type of a filed can be a
string, double, int, date, hex or color.

*** Body section: timestamped events
\label{subsection.events} 

After the events definition, the events themselves are described, one
in each line. Every event starts with its identifying number, which
was defined previously, followed by the fields separated by space or
tab. Before the entities, such as states or links, can be created, a
hierarchy of types and containers must be defined and containers need
to be instantiated, since every entity belongs to a container. There
are sets of events associated to each kind of entity described above,
besides the events that define entity types.

The Pajé objects are organized in two separated hierarchies: types and
entities. These hierarchies are specific for each trace file, although
it can be repeated in traces with the same scenario. In the structure
of the trace file, the type hierarchy comes just after the event
definition. There, each type of the program is defined and one of the
fields is always the parent type. Each entity is always associated to
a type and they must follow the same precedence as the types
definition. For example, as shown in Figure \ref{fig.hierarchyex}, if
the container C1, of type T1, is the parent of the container C2, of
type T2, the type T2 must be child of T1 in the type tree. The root
type is always the number $0$. The difference between both hierarchies
relies on the number of nodes: while the type hierarchy has only a
few, the entities hierarchy may have millions depending on the number
of containers in the trace.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Example of ER Model}
\centering
\includegraphics[width=\linewidth]{./img/hierarchyex.pdf}
\label{fig.hierarchyex}
\end{figure}
#+END_LaTeX

Type definition events don't have a timestamp field and can occur at
anytime in a trace file, as long as the type is not used before its
definition. It is more common to have all the types defined in the
beginning. The events associated to the containers are timestamped and
can create or destroy instances during the trace file. A container
cannot be referenced after it was destroyed. Variables can be set at a
specific timestamp and have its value changed throughout the
simulation by addition and subtraction events. The value of a variable
is a double precision floating-point number, which is different from
the values of the other entities. A variable must be set before
changes to its value can be made.

** PajeNG
\label{section.pajeng}

The PajeNG implementation is the new generation of the Pajé
Visualization Tool \cite{pajeng}. It was developed in C++ and follows
the same architecture as the original Pajé, written in Objective-C. It
comprises a library containing the core of the simulation (*libpaje*),
a space-time visualization tool and some auxiliary tools to manage the
trace files. The base for the implementation of this project was the
*libpaje* library.

The library, represented in Figure \ref{fig.pajeparco} has three main
components forming a pipeline that results in complete simulated
entities. These components are: *FileReader*, *EventDecoder* and
*PajeSimulator*. First, the *FileReader* reads a chunk of data from
the trace file and puts it in memory. Then, the *EventDecoder* breaks
it into events identifying, line by line, the event's fields and
creating an object with all the necessary information. Last, the
*PajeSimulator* receives this event object and addresses to the proper
simulation. 

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{PajeNG Architecture [inspired in \cite{kergommeaux2000paje}]}
\centering
\includegraphics[width=\linewidth]{./img/pajeparco.pdf}
\label{fig.pajeparco}
\end{figure}
#+END_LaTeX

Pajé was idealized to be extensible, specially in terms of creating
new types of events. Actually, the Pajé format itself is very
expandable, which makes it necessary to build a simulator
accordingly. This flexibility is implemented by a class hierarchy,
going from the most general, containing the basic fields common to
every type and entity, to the most specific. Besides, the PajeNG tool
supports extra fields in the events, which allows the simulation of
extended entities. There are three main class hierarchies that are
particularly important in this objective: one for events, one for
types and one for entities. With this modular implementation, it is
relatively easy to add a new type of event or entity and integrate it
with the rest of the code.

*** Class hierarchy for Paje events

An event object is what is passed as an argument to the simulator so
that it can be processed. Therefore, it must contain all of the
necessary information for the simulation. The first object created
when a trace file is being parsed is of type *PajeTraceEvent*, which
is a class containing all the fields read by the *EventDecoder*. As
depicted in Figure \ref{fig.eventsHierarchy}, the event hierarchy
starts with a simple *PajeEvent* class. This class has a trace event
object, a container, a type and a timestamp. The immediate childs of
PajeEvent are: *PajeCategorizedEvent*, *PajeVariableEvent* and
*PajeDestroyContainerEvent*. The variable event is the parent of the
specific events for variables, which are set, add and subtract. A
categorized event is characterized by having a *PajeValue* associated
to it, thus, *PajeStateEvent*, *PajeEventEvent*, *PajeLinkEvent*, and
their respective childs inherit from it.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Events class hierarchy}
\centering
\includegraphics[width=\linewidth]{./img/eventsHierarchy.pdf}
\label{fig.eventsHierarchy}
\end{figure}
#+END_LaTeX

*** Class hierarchy for the Paje types

Figure \ref{fig.typesHierarchy} portrays the type hierarchy, where the
first element is the *PajeType*. It has a name, an alias and a parent
type, which is also a PajeType. These fields are the ones common to
all the type definition events described in section
\ref{section.pajeformat}. The immediate childs of this class are:
*PajeCategorizedType*, *PajeVariableType* and *PajeContainerType*. As
the events, the categorized types are associated to a value, hence,
the PajeCategorizedType has a PajeValue field and methods to
manipulate it. Its childs are the *PajeStateType*, *PajeEventType* and
*PajeLinkType*.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Events class hierarchy}
\centering
\includegraphics[width=.6
\linewidth]{./img/typesHierarchy.pdf}
\label{fig.typesHierarchy}
\end{figure}
#+END_LaTeX

*** Class hierarchy for the Paje entities

As demonstrated in Figure \ref{fig.entitiesHierarchy}, the
*PajeEntity* is the first node of the entities tree. It originates a
*PajeSingleTimedEntity* class, that describes entities with one single
timestamp. The *PajeUserEvent* is the only entity with this
characteristic, but it is possible to add, in the future, more
entities with just one timestamp. The *PajeDoubleTimedEntity* inherits
from this class and represents entities with start and end
timestamps. Like the other hierarchies, the valued entities are
grouped together so a *PajeValuedEntity* is a child of the double
timed entity, having *PajeUserState* and *PajeUserLink* as
descendents. The double timed entity also has *PajeUserVariable* and
*PajeNamedEntity* as childs. A *PajeContainer* inherits from the named
entity.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Entities class hierarchy}
\centering
\includegraphics[width=\linewidth]{./img/entitiesHierarchy.pdf}
\label{fig.entitiesHierarchy}
\end{figure}
#+END_LaTeX

*** The core simulator

All the simulation is performed in two classes: *PajeSimulator* and
*PajeContainer*. A PajeSimulator object is instantiated in the
beginning of the program and incorporates all the event processing of
the simulation. The type definitions, container creations and entity
value declarations are completed and stored in the PajeSimulator
object. Every time there is an event of type *PajeCreateContainer*, a
PajeContainer object is instantiated. All other events are always
associated to a container, thus, they will be simulated in the
appropriate container instance. The PajeContainer object will keep the
entities until the program finishes. Since all the data from the
simulation is kept in memory, the end timestamp is used to signal that
an entity no longer can be referred.

The PajeSimulator class lists every type declared and container
created throughout the simulation by using map structures (=typeMap=
and =contMap=) with the name or alias as key. There is always a
pointer to the root type and another to the root container initialized
in the beginning of the program.  The simulator contains one method
for each type of event described in Appendix \ref{ap.events}, which
perform all the validations, besides the processing itself. Whenever
there is an event that defines a type the entity generated is added to
the =typeMap=.  =contMap= and the proper method of the container
object is called.

The PajeContainer class also uses map structures to store all the
entities that are related to it including other containers. Besides
one general structure that lists all of the objects related to the
container (=entities=), there are auxiliar structures for some
specific types, such as states (=stackStates=) and links
(=pendingLinks=). There is some redundancy between =entities= and the
other constructions but, since the objects are pointers, the changes
made in one structure are reflected in the other ones.

Every event that pushes a state will add a state entity to the end of
the =stackStates= stack, while every pop state event will "remove" the
last state in the vector by setting its end time. The simulation keeps
track of the pending communication links and fails if a container is
destroyed, or the simulation ends, before all the links are
completed. The PajeContainer class contains a method for each event
that is associated to a container, adding and removing entities of
these structures listed above.

** Issues of PajeNG

The focus of the Pajé implementation is to allow the user to extend
the Pajé format and adapt the simulator to it. Its support for extra
fields allows the inclusion of different descriptions for the events
and its modularity facilitates the integration of new
classes. Altering or adding simulation behavior can be done by
modifying only the =PajeSimulator= and =PajeContainer=
classes.

Although complying with its goal of extensibility in terms of
expanding the Pajé format, we identified three main issues in the
current implementation of PajeNG: little flexibility in the
manipulation of data, lack of partial outcomes, and ephemeral
results. When the entities are already simulated, a deeper
understanding of the code structure is necessary if one wants to
define another way of handling the results. Also, the user needs to
manage a full set of entities, since there is no flexibility of
discarding data that is not relevant. The second issue relies on the
fact that the *PajeSimulator* instance maintains all of the simulated
objects in memory. If a user wants to see the resulted entities during
the simulation, he would need to get into the *PajeSimulator* code to
make the necessary changes. Technically, since all the results are
stored in memory, it would be simple to add a new functionality, but
it is limited to the manipulation of the whole set of results, not
each entity separately. Last, the results kept in memory during
simulation are discarded at the end, which implies in executing all
the simulation again if a trace file needs to be revisited.

Considering the presented issues, an extensible simulator written in
Java was developed. The intention of this proposal is to make the
simulation core more transparent for the performance analyst providing
the created entities in a way that he can manipulate them without
looking to the rest of the implementation. The program uses the
concept of plugins that attached to every type of event. The simulator
itself addresses the first issue presented, while the creation of new
plugins provide a possible solution to the other two. The details of
this novel approach, developed in our work, are detailed in the next
chapter.

* Aiyra - Java-based simulator
\label{chapter.aiyra}

Aiyra is an extensible simulator written in Java that reads trace
files in the Pajé format and, instead of storing the results in
memory, forwards every created entity to a common place where it can
be manipulated freely. The architecture of the implementation,
characterized in Figure \ref{fig.aiyraArchitecture}, contains three
packages: *controller*, *simulator core* and *plugin*. Every event of
a trace file always goes through all packages. First, the trace
file in the input is read by the parser, where a trace event object is
created. This instance contains the type of event in question and the
field values. In the example of Figure \ref{fig.aiyraArchitecture},
the event read is the creation of a container of type *P* with alias
*P1* and parent *0*, which is root. Then, the simulator receives this
object and executes the simulation based on the event type. The
simulation always generates an entity, even if incomplete. In Figure
\ref{fig.aiyraArchitecture}, a *PajeContainer* is created without an
ending timestamp. Finally, this new entity is sent to the plugin,
which contains specific entry points for every different kind of
entity.


#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Aiyra Architecture}
\centering
\includegraphics[width=\linewidth]{./img/aiyraArchitecture.png}
\label{fig.aiyraArchitecture}
\end{figure}
#+END_LaTeX

The program receives arguments from the user in its execution. The
*filename* option (=-f=) is the only mandatory one, which indicates
what is the trace file to be simulated. There are other two general
options: *comment* (=-m=), a comment about the file; and *plugin*
(=-p=), which indicates which plugin will be used in the
simulation. The details about the already implemented plugins are 
presented in chapter \ref{chapter.plugins} and a step-by-step 
execution of Aiyra can be found in Appendix \ref{ap.aiyraexecute}. The
following subsections detail each one of the packages.

** The controller: option handling and JavaCC


The controller package is the entry point of the program, thus, it
also handles the arguments passed by the user. For this processing, an
external library \cite{optionhandler} was used. The arguments handling
is centralized in one single class, *OptionsHandler*, to facilitate the
inclusion of new ones. The Paje file format (see Section
\ref{section.pajeformat}) is parsed by a grammar written using the
JavaCC syntax. The file =PajeGrammar.jj= containing all the grammar
rules of the format is processed by the Java Compiler Compiler
(JavaCC) to generate the parser.  Each event definition is stored in
an array, while the events are simulated as soon as they are obtained
from the trace.

The controller package is composed by all of the JavaCC files
described in Section \ref{section.javacc} and the OptionsHandler
class. The generated class =PajeGrammar.java= contains, besides the
parsing component, all the necessary Java code for the program to run,
such as the initialization of the simulator object, where all of the
simulation takes place. Every time an event is identified, the
simulator instance, which is the entry point of the simulator core
package, is called to simulate that event. The next section describes the
simulator core package. For details about the OptionsHandler class and
the complete grammar created for the Pajé Format refer to Appendix
\ref{ap.optionshandler} and \ref{ap.grammar}.

** Aiyra's core simulator

Aiyra's core simulator follows the exact same structure of the
*PajeNG* implementation described in section \ref{section.pajeng},
having the same class hierarchies. Thus, it is equally expandable in
terms of creating new types of events or entities. However, it does
not support extra fields in the events since the focus on the
implementation was extending the output of the simulator. This
makes our solution more limited for changes in the Pajé Trace file,
which happens not very often. Despite that, it would be simple 
to adjust it since changes do not affect the
implementation of the plugins.  As in the *PajeNG*, all of the events
go through the *PajeSimulator* object, which forwards to the
*PajeContainer* if it is an event associated to a container.

_Comments_:
- A figure explaining the behavior of the PajeSimulator and its
  relationship with the PajeContainer would be nice. I think that from
  here on you describe all the specific details of the implementation
  without giving the reader a proper preparation stating how the
  simulator actually _works_. Note that it is important to have an
  abstract understanding of the behavior before diving in details. If
  you start with details, nothing can be understood.
- Input on the left; output on the right: on the center, the
  PajeSimulator and on its right the multiple PajeContainers. You can
  use a specific example with three containers and very few
  timestamped events regarding states, for example.
- I just figured out the existence of Figure \ref{fig.aiyraCore}. It
  is exactly that, but focused on an example regarding the behavior of
  your simulator (you can even use a component to represent your
  grammar) in particular. You would have here another figure then.

Every entity generated is represented by an object with attributes
representing its fields. The class hierarchy of the entities is the
same as the one presented in Figure \ref{fig.entitiesHierarchy}. All
of the types derive from the *PajeType* class, which contains *alias*,
*name*, *depth*, and *parent*, a *PajeType* as well, as attributes. It
also provides the =getNature()= method, to identify which entity this
type describes. The nature is an enumeration and can assume
*ContainerType*, *StateType*, *EventType*, *LinkType* or
*VariableType*. The *PajeVariableType* adds a *PajeColor* to its
attributes, which is an object with the values for red (=r=), green
(=g=), blue(=b=) and alpha(=a=). The *PajeLinkType*, in turn, includes
*startType* and *endType*, which stand for the type of the start and
end containers of the communication. A value is represented by a
*PajeValue* class, with *name*, *alias*, *type* and *color* as
attributes.

A container object (*PajeContainer*) has an *alias*, *name*, *type*
and *parent* (another *PajeContainer*), besides the structures to
store the entities related to it, as described in section
\ref{section.pajeng}. Since the container class is a child of the
*PajeDoubleTimedEntity*, it also has a *startTime* and an
*endTime*. All other entities are associated to a container and a
type, thus, they have a *container* and a *type* fields. The event
entity (*PajeUserEvent*) is the only one that derives from
*PajeSingleTimedEntity*, hence, it has a unique timestamp named
*time*. Also, it has a *value* attribute, which is a *PajeValue*. The
other valued entities, *PajeUserState* and *PajeUserLink*, inherit the
*PajeValue* attribute from the *PajeValuedEntity* class. A
*PajeUserVariable* object also has a *value* attribute but, unlike
events, states and links, it is a double number. The *PajeUserLink*
has a string that defines the *key* and start and end containers
identified by *startContainer* and *endContainer*.

Every trace event simulation has an instrumentation point, which
dispatches the entity objects generated to the plugin package. These
points are either in the *PajeSimulator* or in the *PajeContainer*, as
illustrated in figure \ref{fig.aiyraCore}. In the *PajeSimulator* are
the outputs regarding the definition of types and values and the
creation of containers. Although in this point the containers are not
complete objects, since they don't have ending timestamp or the
related entities, they are forwarded anyway with the alias and type
information. The *PajeContainer* is in charge of dispatching to the
plugin the instances related to it, which involve the states, events,
links and variables. It also may send unfinished objects. When there
is a *PajeDestroyContainerEvent*, the container object is sent again,
now complete with an ending timestamp.

_Comments_:
- Remove all future tense, replace by present (generic comment valid
  for the whole text)
- Do not use "don't", since its informal. Please stick to the more
  formal form "do not".
- I still have to do a complete review on your implementation, but I
  have the feeling that =aliases= should be left apart from the plugins
  sector.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Aiyra's Core Architecture}
\centering
\includegraphics[width=\linewidth]{./img/aiyraCore.png}
\label{fig.aiyraCore}
\end{figure}
#+END_LaTeX

_Comments_:
- Figure is too big
- Remember that you can have multiple containers instances. Maybe
  represent that somehow on this figure.

The choice of creating an instrumentation point for each trace event
is due to the intention of covering all of the different needs of the
user. One may need the container name before it can process the
entities related to it, for example, which cannot be achieved by
receiving the container only when it is completed. Or else, may be a
situation where the push state events need to be measured, instead of
the pop state events, where the entities are finished. Since we cannot
predict all of the use cases, it is desirable to have a broad
approach. A full list of the plugin entrances and the information
received in each one is presented in the next section.

_Comment_:
- when you send a complete "state" object, you already have the
  reference for the container, right?

** The plugin package
\label{section.plugin}

_Comment_:
- Give an overview first! Please!
- By reading the first phrase you already have details.

The plugin package is composed by an abstract class, the *PajePlugin*,
with one method for each instrumentation point. It also contains a
method called *finish* where the user can perform some concluding
actions after the simulation is completed. To create a new plugin, the
user just needs to extend the *PajePlugin* class and override its
methods. It is also possible to extend another existing plugin, if the
differences are small and not worth of a new class
implementation.

The entrances of the plugins comprise the definition of types and
values, the creation of containers, and the formation and completion
of new entities. The *newType* entry point is a unique entrance for
when a type of any kind is defined, having the *PajeType* object as
argument. The =getNature()= method can be used to identify the exact
type. The *newValue* method receives every *PajeValue* created.

_Comment_:
- Do you mean that the plugin has to call =getNature=?

When a container is created in the simulation, the instance is
forwarded to the *newCreatedContainer* entry point, with the end
timestamp set to $-1$. Whenever a method receives an entity that is
not completed yet, the end timestamp will be $-1$. The
*destroyedContainer* method takes in a complete container that has
just been destroyed. Most of the entities are removed during
simulation, but the destroyed container may have some remaining ones
that could not be excluded, such as variables.

Link entities have three instrumentation points all receiving
*PajeUserLink* objects: *startLink*, where the end time and end
container of the communication link are unknown; *endLink*, when the
instance has the end point of the link but not the start; and
*newCompleteLink*, where the link entity has beginning and
end. Anytime a variable is set or updated, there are three
*PajeUserVariable* entities sent to the plugin: the *first*, which
contains the first value of the variable; the *last*, which is the one
immediately before the variable in question; and the new variable
which is not completed yet (*newVar*). The aditions and subtractions
are sent to the same point (*updateVar*). Since the previous variable
objects are necessary to generate the new value, they are not removed
from memory during simulation. The set, push and pop state events each
have one method receiving a *PajeUserState*: *setState*, *pushState*
and *popState*, the only one with an entity with beginning and end
timestamps. The *PajeUserEvent* objects are sent to the *newEvent*
function.

To validate the concept of the plugins and its entry points, three
plugins were created: *PajeNullPlugin*, *PajeDumpPlugin* and
*PajeInsertDBPlugin*. Their implementation is described in the next
chapter.
  
* Plugins
\label{chapter.plugins} 

In this chapter, two plugins are described: *PajeDumpPlugin* and
*PajeIsertDBPlugin*. The *PajeNullPlugin* is the default one. It does
not make any treatment to the data so the objects are simply
discarded. It is useful to verify the performance of the simulation
itself, whithout the interference of the other segments.

** Paje Dump Plugin

The Dump plugin performs the same action as the *pj_dump* tool, which
dumps to the standard output the entities generated by the
simulator. The implementation consists in inserting a =print= function
in each instrumentation point that receives a complete entity. These
points are: *destroyContainer*, *popState*, *newCompletedLink*, and
*newEvent*. When it is a destroyed container, it is necessary to
iterate over the entities left in the container. The variables printed
in the destruction of the container, since they are not removed during
simulation.

The difference between the *PajeDumpPlugin* and the *pj_dump* tool is
that the first one outputs the information as soon as the entity is
completed. The *pj_dump*, in turn, keeps everything in memory before
dumping it all at once. With this approach, it is possible to solve
the issue regarding the need to wait for the program to end to have
the results.

This plugin can be called with the argument =pjdump= in the =-p=
option and adds a new argument (=-l=) that can group together a
certain number of entities before dumping it. The option receives an
integer as parameter defining the number of lines it should reach
before dumping the entities. This provides a little more flexibility
for the user and may improve the performance, since the printing
function of Java costs time. For it to be possible, a =StringBuilder=
is used as a buffer keeping all of the output until it reaches the
number of lines desired.

** Paje Insert Database Plugin

The *PajeInsertDBPlugin* saves in a relational database all the
results of the simulation. For the implementation, the JDBC API was
used to make a connection with the MySQL database. The schema used was
specially designed for the Pajé format and is presented in the next
subsections. This plugin allows the user to save data from multiple
files in the same database.

The plugin can be used by specifying =mysql= as argument for the =-p=
option. It is necessary to have a MySQL connection and a database with
the correct schema. To specify the server of the connection, there is
the option =-s=. It is also possible to inform a username (=-u=) and a
password (=-pwd=). The default for these options is: *localhost*,
*root* and *root*, respectively.

To create a relational database for the Pajé format, first, we created
an entity-relationship model that is described in the subsection
below.

*** Entity-Relationship Model

The entity-relationship (ER) model, illustrated in Figure
\ref{fig.ermodel}, contains one entity for each type of Pajé
object. Also, to support multiple files, there is a *file* entity,
which has the *name*, a *comment* and the *date* as attributes, as
well as a *file_id*. The *Type* and *Container* entities have an
identifying relationship with *file*, which means that the file id is
part of their identifier. The relationship is one-to-many, since a
file can have multiple types and containers.

The *Type* entity has *alias*, composing the identifier, *name* and
*depth* as attributes. It also contains a self-referencing one-to-many
relationship to indicate the *parent* type, as a type can have
multiple children. It is associated to a *Value* entity, which
describes the *PajeValue* class, with *alias*, *name*, *type*
(identifying relation) and *color*. Link and variable types have
exclusive attributes that are not common to all types, thus, both are
specializations of *Type*. *LinkType* adds a relationship with itself
to represent a the start and end. This is a many-to-many relationship
because the types can be the start and end to various
communications. The *VariableType* has a color attribute.

The *Container* entity has an identifying one-to-many relashionship
with *Type*, as well as every other entity, since all of them are
classified by a type. Containers have the same attributes as types,
including the *parent* one-to-many relation. All of the entities that
are related to a container, have an identifying one-to-many relation
with *Container* entity. *State* has *startTime* and *endTime*
attributes, where the first is identifier. *Link* has two one-to-many
relationships with *Container*, one for *startContainer* and one for
*endContainer*. A *Variable* entity contains the *Time* attribute, as
well as an *updateTime* in the relation with *Container*. Also, this
relation has a *value* attribute. The *Event* entity has a *time*
field.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{ER Model for the Pajé format}
\centering
\includegraphics[width=\linewidth]{./img/ermodel.png}
\label{fig.ermodel}
\end{figure}
#+END_LaTeX

*** Relational Model

After the creation of the conceptual model, a translation to a logical
model was made. In this conversion, besides applying the universally
known rules presented in chapter \ref{chapter.basic_concepts}, we
considered the usability of the schema, analysing the common
consultations made in the Pajé data. This reflection is a usual part
of the process, where the needs of the client are contemplated.

The entities defined in the ER Model all became tables. For the *Type*
specialization, we used the first option presented in
\ref{subsection.er_relational}: combining everything in a single table
with the following fields: *file_id*, *alias*, *name*, *depth*,
*parent_type_alias*, *start_link_type*, *end_link_type* and
*color*. *File_id*, inherited from the identifying relation with
*File*, and *alias* compose the primary key. The self-referencing
relationships are described as foreign keys in their tables.  The
entities associated to the container all have at least three foreign
keys that are also identifiers: *type_alias*, *container_alias* and
*file_id*. Since the *Link* entity has a unique key, its two foreign
keys from *Container* don't belong to the identifier.

In our ER Model, the value is only associated to the *Type*, thus, if
one wants to know the value of a state, for example, it needs to first
get its type, then, go to *Type* table to retrieve the value. Since it
is desirable to easily get an entity's value, we added a relationship
between the valued entities (*State*, *Link* and *Variable*) with
*Value*. *value_alias* is an identifying foreign key for all, except
*Link*, where the identifier consists only in the *key*, *type* and
*file_id*. With the conceptual model of the *Variable* entity, it is
required to retrieve two rows if one needs to know the beginning and
ending timestamps of one entity. Since this information is very
important, we changed the *Variable* table for the tuples to
explicitly have *startTime* and *endTime*.

*** Implementation

In the *PajeInsertDBPlugin*, the following entry points were used:
*newType*, *newValue*, *newCreatedContainer*, *destroyedContainer*,
*popState*, *newCompleteLink*, *updateVar* and *newEvent*. Types,
values and containers are inserted in the database as soon as they are
created due to the dependency of other entities on these ones. When a
container is destroyed, its *endTime* is updated in the database.

The insertion in the database costs time, hence, the approach of
making an access every time a new entity is created has a very bad
performance. To solve this problem, we used the mechanism of *batches*
provided by JDBC, which sends a block of queries all at once, reducing
the communication overhead. This functionality is optional and can be
included by adding the (=-batch=) option with an integer as
argument. This number will define how many queries it will store
before inserting a batch in the database. This is only appliable to
states, events, links and variables, since types, values and
containers are immediately inserted. An analysis of the performance
for different sizes of batch will be presented in the next chapter.

* Performance Evaluation
\label{chapter.performance}

An evaluation of Aiyra's performance was made to have a concrete
results about the outcome of this proposal. Two main tests were
executed: a comparison between Aiyra and PajeNG and an analysis of the
impact of different batch sizes in the *PajeInsertDBPlugin*. Since
Aiyra is strongly based in the PajeNG implementation, it is valid to
examine if the modifications and language transition have brought
significant performance impact on the simulation. The plugin that
inserts the data in a MySQL database is the only one that brings an
extremely different functionality to the program, hence it was chosen
to be studied. As it involves the connection with an external tool,
the analysis of its performance and the study of the most efficient
use of it is very important.

We used full factorial experimental design, using the R language with
*DoE.base* package, to define the tests to be performed. The package
generates a *.csv* file with one column for each factor. It creates
one row for each possible combination of the different levels and
multiplies it by the number of replications. We created *bash* scripts
to execute the experiments of the design generating another *.csv*
sheet including the response variables defined for the
experiments. The details about the factors and levels for each test
are described in the next section.

** Methodology

The experiments were performed in three different machines: *luiza*,
with a Mac OSX environment, *guarani*, and *orion1*, both running
Linux. The details about the experimental units are described in table
\ref{tab.machines}. We generated three input trace files with
different sizes identified by *small*, *medium*, and *big*, of sizes
128K, 128M, and 1G, respectively.

#+BEGIN_LaTeX
\begin{table}[h!]
  \centering
  \caption{Description of the machines}
  \label{tab.machines}
  \begin{tabular}{ccc}
    \toprule
     luiza & guarani & orion1\\
    \midrule
    OSX Yosemite 10.10.5 & Linux Debian 4.3.5-1 & Linux Ubuntu\\
    as & well & as\\
    using & the & booktabs package\\
    \bottomrule
  \end{tabular}
\end{table}
#+END_LaTeX

_luiza_: OS X Yosemite 10.10.5
 Nome do Modelo:	MacBook Pro
  Identificador do Modelo:	MacBookPro10,1
  Nome do Processador:	Intel Core i7
  Velocidade do Processador:	2.7 GHz
  Número de Processadores:	1
  Número Total de Núcleos:	4
  Cache L2 (por Núcleo):	256 KB
  Cache de L3:	6 MB
  Memória:	16 GB
Disco: 500 GB

_guarani_: Linux guarani 4.3.0-1-amd64 #1 SMP Debian 4.3.5-1
(2016-02-06) x86_64 GNU/Linux

Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                4
On-line CPU(s) list:   0-3
Thread(s) per core:    1
Core(s) per socket:    4
Socket(s):             1
NUMA node(s):          1
Vendor ID:             GenuineIntel
CPU family:            6
Model:                 42
Model name:            Intel(R) Core(TM) i5-2400 CPU @ 3.10GHz
Stepping:              7
CPU MHz:               1601.222
CPU max MHz:           3400.0000
CPU min MHz:           1600.0000
BogoMIPS:              6185.49
Virtualization:        VT-x
L1d cache:             32K
L1i cache:             32K
L2 cache:              256K
L3 cache:              6144K


_orion_: Linux orion1 3.13.0-85-generic #129~precise1-Ubuntu SMP Fri Mar 18 17:38:08 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux 

Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                24
On-line CPU(s) list:   0-23
Thread(s) per core:    2
Core(s) per socket:    6
Socket(s):             2
NUMA node(s):          2
Vendor ID:             GenuineIntel
CPU family:            6
Model:                 45
Stepping:              7
CPU MHz:               2000.000
BogoMIPS:              4601.07
Virtualization:        VT-x
L1d cache:             32K
L1i cache:             32K
L2 cache:              256K
L3 cache:              15360K
NUMA node0 CPU(s):     0,2,4,6,8,10,12,14,16,18,20,22
NUMA node1 CPU(s):     1,3,5,7,9,11,13,15,17,19,21,23

model name      : Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz

guarani_orion: 

traceroute to orion1 (143.54.12.114), 30 hops max, 60 byte packets
 1  143.54.13.1 (143.54.13.1)  0.619 ms  0.975 ms  1.329 ms
 2  orion1.inf.ufrgs.br (143.54.12.114)  0.547 ms  0.551 ms  0.544 ms

ping: rtt min/avg/max/mdev = 0.280/0.510/0.559/0.065 ms

rede do inf: 100Mb

*Comparison between Aiyra and PajeNG* 

This experiment evaluates the performance of Aiyra using the
*PajeNullPlugin* and two versions of the *pj_dump* tool: *pj* and
*pjflex*. The difference between the versions is in the parsing of the
trace file, while the first one uses the standard C++ parsing, the
second uses a scanner and parser generator (*flex* and *bison*). The
executions of the *pj_dump* tool received =--quiet= as a parameter to
avoid the actual dumping of the information in the standard output,
since we only needed the execution time. It is important to highlight
that Aiyra does not perform any action in the resulted entities and
discards most of them.

Two factors were chosen for this experiment: *input* and
*version*. The first assumed the values *small*, *medium*, and
*big*. The second, *aiyra*, *pj* and *pjflex*. The number of
replications chosen was $30$, which is the recommended for full
factorial design _*?? help on references*_. Since we have two factors,
each with three levels, we have a total of 270 experiments (the
product of $3*3*30$). The execution of the design added a column for
the platform and another for the execution time in the resulting
*.csv*. This design was run in each one of the platforms, thus, we had
three files each with $270$ rows.

(header of the design?)

*PajeInsertDBPlugin evaluation*

The *PajeInsertDBPlugin* provides an option for the user to define a
batch size for the insertion in the database. The size defines the
number of entities to be inserted at once. This means that the queries
are stored in a buffer until a counter reaches the specified
value. Although this approach reduces the number of accesses to the
database, reducing the execution time, it occupies a significant
amount of memory. Our evaluation aims to define what is the best
choice of batch size for different scenarios.

For this experiment we used the same experimental units as the first
one, but we added a fourth experiment which consists in the remote
access between *guarani* and *orion1*. In the experiment, we had the
simulator running in *guarani* and accessing the database in
*orion1*. Figure \ref{fig.infnetwork} represents the network
connecting the machines. Both are in _*INF em ingles ou portugues? e
ufrgs?*_, where the bandwidth is 100Mb/s. There is one switch between
both endpoints, which is what limits the network speed. 

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{ER Model for the Pajé format}
\centering
\includegraphics[width=\linewidth]{./img/infnetwork.pdf}
\label{fig.infnetwork}
\end{figure}
#+END_LaTeX

The factors for this evaluation consist in the *input*, the same as
the ones described above, and *batch*, which assumes five different
values. The *batch* factor consists in the size of the batch to be
ineserted in the database. The number is not fixed and varies among
the different input sizes. The levels are classified from *A* to *E*,
where *A* represents the highest number possible for a batch, meaning
one single insertion. The other four levels consist in dividing the
previous one by half. The *A* value for each input size was previously
calculated and the rest were generated by the dividing the first one.

To complement this analysis, we also implemented a trace for the batch
insertions. Every time there was an insertion in the database, we
collected the *start time*, *end time* and *size* of that specific
batch. This data is useful to obtain richer information about the
impacts of the batch mechanism in the performance. Next section
demonstrates the results for the experiments described above.



** Results and Graphics

We used the R language to merge the data from the different files
generated and to plot significant graphics of the results. The
hipotesis made before the execution of the experiments and the
observed results are presented below.

*Comparison between Aiyra and PajeNG*

For the experiment of comparison between Aiyra and PajeNG, we used the
average execution time among the $30$ replications as a mesurement. We
considered the standard error to be three standard deviations of the
mean, which cover 99.7% of the cases in a normal distribution
\cite{normaldistribution}.

/Expected/ It is universally known that C++ is a language with better
performance than Java. We suppose that Aiyra will be slower than
PajeNG, but with an acceptable execution time. It is also expected
that the version *pj_flex* will be slower than *pj*, since *flex* has
the characteristic of having lower performance.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Results of comparison between Aiyra and PajeNG}
\centering
\includegraphics[width=\linewidth]{./img/aiyra-pj-pjflex_overview.pdf}
\label{fig.cppoverview}
\end{figure}
#+END_LaTeX

/Observed/ We can see in Figure \ref{fig.cppoverview} that, for the
*medium* and *big* inputs, Aiyra was actually faster than both
versions of PajeNG. To understand this results it is crucial to
recognize the difference between the implementation and configuration
of both programs. Aiyra is designed to get rid of the entities as soon
as they are finished. Thus, with the *PajeNullPlugin*, very little is
kept in memory. One of Java's biggest overhead is the memory handling,
specially the Garbage Collector. Since we have an implementation that
stores as few objects as possible, Java may have a chance in this
case. Likewise, the *pj_dump* implementation carries the overhead of
storing everything. As expected, the *pj_flex* version was slower than
*pj*.

Notice that the execution in *luiza* had a bigger variability in the
execution the *pj* version with the *big* input. The average execution
time for the big file in the *aiyra* version was around $80$ seconds,
but there was an outlier experiment that executed in $2888$
seconds. This particular row was removed from the data set. Even with
this particular case deleted, an instability can still be
perceived. The experiments are randomized in the design, so if there
was any disturbance in the environment during the experiment, it
should have affected other configurations as well. Besides, we can
notice the variability only in this particular configuration. There is
no confirmed explanation for this situation, it may be because *luiza*
is the weakest machine in the experiment and did not handle well the
C++ parsing with the biggest file. Considering that it does not affect
the overall analysis, the experiment was considered valid.

So far, we have analysed the execution time of the *medium* and *big*
inputs. In Figure \ref{fig.cppoverview}, we don't have a clear view of
the difference between the results of the *small* input in the
different platforms. Figure \ref{fig.cppsmall} portrays a closer sight
of the graphic, where we can see that the bahavior for the *small*
input is different from the others. In this case, we observe the
expected result. This is probably because it is a very small file,
with very few entities, so there is no memory overhead in either
versions and C++ is naturally faster than Java.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Results of comparison between Aiyra and PajeNG for the small input}
\centering
\includegraphics[width=\linewidth]{./img/aiyra-pj-pjflex_small.pdf}
\label{fig.cppsmall}
\end{figure}
#+END_LaTeX

This results are particularly important to assure the relevance of
this proposal. By deattaching the core simulation from the data
handling, we perceive that there is room for performance improvements
in the replay of large Pajé trace files. It is possible to observe
that the fewer we retain in memory, the better our performance will
be. The implementation of Aiyra gives the user more flexibility to
manage the memory usage of his program and space to develop high
performance implementations.

*PajeInsertDBPlugin evaluation*

the test options: platform, -test to not interfere with memory, etc.

* Conclusion
\label{chapter.conclusion}

- not only the simulator
- plugins are important

*Future Work*
- Plugins in other languages

#+LATEX: \bibliography{References}


\appendix
* JavaCC Tutorial
\label{ap.javacc}

To build a grammar that will be compiled by =JavaCC= you only need to
create one file whith `.jj` extension. The structure of this file is
the following:

#+BEGIN_EXAMPLE
options{

}
#+END_EXAMPLE

A set of optional flags. An example, is the flag =STATIC=, which means
that there is only one parser for the JVM when set to true.

#+BEGIN_EXAMPLE
PARSER_BEGIN(MyGrammar)

public class MyGrammar {

}

PARSER_END(MyGrammar)
#+END_EXAMPLE

In this part, the Java code will be placed and it's the main class of
the program. Notice that the class must have the same name as the
generated parser.

#+BEGIN_EXAMPLE
TOKEN_MGR_DECLS:
{

}
#+END_EXAMPLE

The declarations used by the lexical analyser are placed in the
TOKEN_MGR_DECLS function.

Below these three structures, comes the lexical analysis where the
Token rules and parser actions can be written using a top-down
approach. First, the Tokens are declared, always using the word
"TOKEN" before. To exemplify the creation of a grammar in JavaCC, we
will create a language that consists in the declaration of integer and
char variables and assignments of values to these variables. All the
declarations come first, then the assignments. No verification will be
performed since it is just an example to clarify the JavaCC syntax. To
declare tokens, we use the following notation:

#+BEGIN_EXAMPLE
TOKEN: 
{
  < [NAME] : [EXPRESSION] >  
}
#+END_EXAMPLE

For our example of language we will have the following tokens: 

#+BEGIN_EXAMPLE
/* Integer Literals */
TOKEN : 
{
  < INTEGER: "0" | ["0"- "9"] (["0"-"9")* >
}

/*Variables, assignments and char values*/
TOKEN : 
{
  < VARIABLE: (["a"-"z", "A" - "Z"])+ >
  < ASSIGNMENT: "=" >
  < CHAR: (~["\""] | "\\" (["n","r","\\","\'","\""])) >
} 
/* Types */
TOKEN: 
{
  < INTEGER_TYPE : "int" >
  < CHAR_TYPE: "char" >
}
#+END_EXAMPLE

As we can see in the definitions above, it is not necessary to
explicit the word TOKEN for each one. It is usually separated to be
better organized and easier to understand. Although the token's
agroupation is not relevant, the order in which they are declared
is. When an input matches more than one token specification, the one
declared first will be considered.  There is also another kind of
regular expression production, which is the SKIP. Whatever matches the
regular expression defined in the SKIP scope will not be treated by
the parser.  Example:

#+BEGIN_EXAMPLE
SKIP: 
{
  "\n" 
  \| "\t"

} 
#+END_EXAMPLE

After the token declaration, comes the grammar rules. The rules are
declared as methods, that can have return values or not. The structure
of a method is the following:

#+BEGIN_EXAMPLE
[type] [name] ()
{}
{ 
  /* Rules */
}
#+END_EXAMPLE

The empty braces in the beginning of the method can be filled with
variable declarations in Java. More Java code can be added in the
middle of the rules by using braces. Inside the next braces, it is
possible to assign tokens, regular expressions or even methods to the
variables declared earlier. To refer to the tokens, we use its name
between angular brackets. Example:

#+BEGIN_EXAMPLE
void parser()
{ int number; }
{
  number = <INTEGER>
}
#+END_EXAMPLE

The first method defined will be the entrance to the parser and it can
contain methods inside that will be expanded later in the rules. The
entrance for the language we are using as an example would be as
follows:

#+BEGIN_EXAMPLE
void start()
{}
{
  declarations() assignments() <EOF>
}
#+END_EXAMPLE

EOF is a default token. It is important to guarantee that the file
will be parsed until the end. By the definition of our first method,
we assure that the declarations will obligatorily be in the beginning,
and the assignments at the end. Next, we expand the two methods to
address all the possibilities:

#+BEGIN_EXAMPLE
void declarations()
{}
{
  ((<INTEGER_TYPE> | <CHAR_TYPE>) <VARIABLE>)*
}

void assignments()
{}
{
  (<VARIABLE> <ASSIGNMENT> (<CHAR> | <INTEGER>))*
}

#+END_EXAMPLE

The multiplicity can be defined with the standard characters "*", "?",
"+", just as in the lexer. This example is just one possible approach
to define these rules. For example, you can use another non-terminal
to describe a value that will be assigned to a variable. In this case,
the assignments() rule would be expanded as follows:

#+BEGIN_EXAMPLE
void assignments()
{}
{
  (<VARIABLE> <ASSIGNMENT> assignable() )*
}

void assignable():
{}
{
  <CHAR> | <INTEGER> 
}
#+END_EXAMPLE

*** Usage with Java

In order to call the parser in a Java program, an object of the
MyGrammar class needs to be instantiated:

#+BEGIN_EXAMPLE
MyGrammar parser = new MyGrammar(input);
#+END_EXAMPLE

Then, once there is an instance of the parser, it is possible to call
the first method of the parser:

#+BEGIN_EXAMPLE
parser.start();
#+END_EXAMPLE

This code has a Java syntax and is placed in the main class presented
previously. Between the declarations of PARSER_BEGIN and PARSER_END,
any Java code can be placed to manipulate the results of the parsing.

#+BEGIN_EXAMPLE
PARSER_BEGIN(MyGrammar)
/* Imports */
public class MyGrammar {
    public static void main(String args []){
        /* Code to read the input */

        MyGrammar parser = new MyGrammar(input);
        parser.start();

       /* Java code to manipulate the parser results */
  
  }

}

PARSER_END(MyGrammar)
#+END_EXAMPLE
* Paje File Format Specification
\label{ap.pajeformat}

The Pajé Trace File Format has two parts: event definition and events.
The format of the event definition part has the following format:

- Every line of the event definition part of the Pajé format starts
  with the character "%".
- An event definition starts with "%EventDef" plus the =name= of the
  event followed by a =unique number= to identify it.
- An event definition ends with "%EndEventDef".
- Between the "%EventDef" and "%EndEventDef" lines there is a list of
  fields, one per line, with =name= and =type=.
- It is possible to have two events with the same name but different
  identification numbers. This is useful to specify different sets of
  fields for the same type of event.

The types of fields can be: 

=date=: a double precision floating-point number, which usually means
the seconds since the program started;

=int=: integer number;

=double=: floating-point number;

=hex=: address in hexadecimal;

=string=: string of characters;

 =color=: a sequence of three to four floating-point numbers between 0
and 1 inside double quotes. The values mean red, green, blue and
alpha(optional).

An example of event definition: 

#+BEGIN_EXAMPLE
%EventDef PajeNewEvent 17
%       Time date
%       Container string
%       Type string
%       Value double
%EndEventDef
#+END_EXAMPLE

** Events
\label{ap.events} 

After the event definition, the events themselves are described, one
in each line. Every event starts with the number that identifies it,
which was defined previously. For the example above, every line that
contains a *PajeNewEvent* event will start with the number 17. The
fields are separated by space or tab and must appear in the same order
as it was declared in the definition. In the example below, there is a
PajeNewEvent event with timestamp =3.14532=, of type =S=, in the
container =p1=, and with value =M=:

#+BEGIN_EXAMPLE
17 3.14532 p1 S M
#+END_EXAMPLE

Fields of type =string= don't need to be double quoted unless they are
empty or have a space or tab character. Before the entities can be
created, a hierarchy of types and containers must be defined and
containers need to be intantiated, since every entity belongs to a
container.

*** Types
Type doesn't have a timestamp and can be declared at anytime in a
trace file, as long as it is not used before its definition. It is
more common to have all the types defined in the beginning. There are
6 different type definitions, one for each sort of entity and one for
value objects:

*PajeDefineContainerType*: Must have the fields *Name* and *Type*, and
can have an optional field *Alias*. Defines a new container type
called *Name*, contained in a previously defined container of type
*Type*.

*PajeDefineStateType*: Must have the fields *Name* and *Type*, and can
have an optional field *Alias*. Defines a new state type called
*Name*, contained in a previously defined container of type *Type*.

*PajeDefineEventType*: Must have the fields *Name* and *Type*, and can
have an optional field *Alias*. Defines a new event type called
*Name*, contained in a previously defined container of type *Type*.

*PajeDefineVariableType*: Must have the fields *Name*, *Type* and
*Color*, and can have an optional field *Alias*. Defines a new
*variable type called *Name*, contained in a previously defined
*container of type *Type*, with the color *Color*. Notice that the
*color is associated to the type, and not to the object. Therefore,
*every variable of determined type will have the same color.

*PajeDefineLinkType*: Must have the fields *Name*, *Type*,
*StartContainerType* and *EndContainerType*, and can have an optional
*field *Alias*. Defines a new link type called *Name*, contained in a
*previously defined container of type *Type*, that connects the
*previously defined container type *StartContainerType* to the
*previously defined *EndContainerType*. Also, the container type given
*in *Type* must be an ancestral of both start and end container types.

*PajeDefineEntityValue*: Must have the fields *Name*, *Type* and
*Color*, and can have an optional field *Alias*. This is an optional
*event that defines the possible values of an entity type, which can
*be a State, Link or Event. Defines a new value called *Name* for the
*previously defined type *Type* with color *Color*. Notice that this
*value is an entity, differently from the one indentifying a variable,
*which is a double value.

*** Containers
Intances of containers can be created and destroyed during the trace
file. A container cannot be referenced after it was destroyed. The
events associated to the containers are timestamped.

*PajeCreateContainer*: Must have the fields *Time*, *Name*, *Type* and
*Container*, and can have an optional field *Alias*. Creates, at
*timestamp *Time*, a container instance called *Name*, of the
*container type *Type* and that is a child of the previously created
*container Container*.

*PajeDestroyContainer*: Must have the fields *Time*, *Name* and
*Type*. Destroys, at timestamp *Time*, a container instance called
*Name*, of the container type *Type*.

*** States
The state events change the values of a determined container's state,
by setting, pushing, popping and reseting.

*PajeSetState*: Must have the fields *Time*, *Type*, *Container* and
*Value*. Changes, at timestamp *Time*, to the value *Value*, the state
*type *Type*, of the container identified by *Container*.

*PajePushState*: Must have the fields *Time*, *Type*, *Container* and
*Value*. Pushes, at timestamp *Time*, the value *Value* of the state
*type *Type*, in the container identified by *Container*. The push
*event saves the existing value of the same state.

*PajePopState*: Must have the fields *Time*, *Type* and
*Container*. Pops, at timestamp *Time*, the last state of type *Type*
*in the container identified by *Container*.

*PajeResetState*: Must have the fields *Time*, *Type* and
*Container*. Clears, at timestamp *Time*, the state of type *Type* in
*the container identified by *Container*. If the stack is empty, the
*event does nothing.

*** Events
An event is something that is relevant enough to be acknowledged and
has a unique timestamp.

*PajeNewEvent*: Must have the fields *Time*, *Type*, *Container* and
*Value*. Instantiates, at timestamp *Time*, a remarkable event of type
*Type*, in the container *Container*, with value *Value*.

*** Variables
Variables are set at a specific timestamp and can have its value
changed throughout the simulation. The value of a variable is a double
precision floating-point number, which is different from the values of
the other entities. A variable must be set before changes to its value
can be made.

*PajeSetVariable*: Must have the fields *Time*, *Type*, *Container*
and *Value*. Instantiates, at timestamp *Time*, a variable of type
*Type*, in the container *Container*, with value *Value*.

*PajeAddVariable*: Must have the fields *Time*, *Type*, *Container*
and *Value*. Adds, at timestamp *Time*, a value *Value*, to an
existing variable of type *Type*, in the container *Container*.

*PajeAddVariable*: Must have the fields *Time*, *Type*, *Container*
and *Value*. Subtracts, at timestamp *Time*, a value *Value*, of an
existing variable of type *Type*, in the container *Container*.

*** Links
A link can start at a container and end in another one. Every
completed link is identified by a unique key.

*PajeStartLink*: Must have the fields *Time*, *Type*, *Container*,
*StartContainer*, *Value* and *Key*. Indicates, at timestamp *Time*,
*the beginning of a link of type _Type_, in container *Container*,
*starting from *StartContainer*, with value *Value*, and identified by
*key *Key*.

*PajeEndLink*: Must have the fields *Time*, *Type*, *Container*,
*EndContainer*, *Value* and *Key*. Indicates, at timestamp *Time*, the
*end of a link of type *Type*, in container *Container*, ending in
*EndContainer*, with value *Value*, and identified by key *Key*.

* PajeNG structures
\label{ap.pajeng}

The main structures used by the PajeNG simulator to manipulate the
entities are the following:

*Simulator*

=typeMap=: a map containing all the types that have been defined in
the simulation, with name or alias as key;

=contMap=: a map of the created containers also identified by the name
or alias.

*Container*

=stackStates=: a map identified by the type and with a vector of state
entities as the value. Every event of type *PajePushState* will add a
state entity to the end of the stack, while every *PajePopState* will
"remove" the last state in the vector by setting its end time;

=pendingLinks=: a map of pending links stores the communications that
were opened but have not been closed yet. The link key is the
identification, and the simulation fails if a container is destroyed,
or the simulation ends, before all the links are completed;

=linksUsedKeys=: a map listing all the keys for links that were
already used in this container.

=entities=: This map lists all the entities that belong to the
container, even if they were already listed in the other
structures. What identifies an entity is its type and container,
hence, the PajeType is the key of this map and a vector of entities is
the value. Here, we notice the importance of having the single parent
type class PajeType, and a unique parent entity class, PajeEntity, to
group together different types of objects. Since the objects are
pointers, the changes made in one structure are reflected in the other
ones. All of the variable and event objects are stored in this general
list of entities.

* Processing Command Line Arguments 
\label{ap.optionshandler}

Since handling command line arguments is not very straightforward in
Java, an external library \cite{optionhandler} was used. The command
line arguments are used for the user to pass information to the
simulator, such as the name of the file to be processed, or a comment
about the trace.

All of the arguments processing is done in one class:
*OptionsHandler*. The options that are needed in the simulation core
are stored in this single class. These are: 

*filename*: a string that receives the name of the trace file to be
read;

*comment*: a string that stores an optional comment about the file;

The centralization of the options has the objective of facilitating
the extensibility of the program. The arguments regarding a specific
plugin are sent directly to its proper object.

The constructor of this class receives the list of arguments that was
passed in the execution of the program and creates an object =opt= of
type =Options= with the arguments as parameter. 

#+BEGIN_EXAMPLE
import ml.options.Options;

public class OptionsHandler {

  public Options opt;

  public OptionsHandler(String args[]) {
	  opt = new Options(args);	
  }
}

Options opt
#+END_EXAMPLE

The Options type is the core of the library used, and all of the
argument's processing will be done in the =opt= instance. It is also
in the constructor that we set all of the possible options that can be
used by the user. To define a new one, we use the following line of
code:

#+BEGIN_EXAMPLE
opt.getSet().addOption("<alias>", Options.Separator.<SEPARATOR>, Options.Multiplicity.<MULTIPLICITY>);
#+END_EXAMPLE

=<alias>=: the alias that will be used to identify the option;

=<SEPARATOR>=: used for options that have a value. Can be *COLON*,
*EQUALS*, *BLANK* or *NONE*;

=<MULTIPLICITY>=: the multiplicity defines if the value is required or
optional, or if it can appear more than once. The possible values are:
*ONCE*, *ONCE_OR_MORE*, *ZERO_OR_ONE*, *ZERO_OR_MORE*.


The default for the prefix is a dash and is the one chosen for the
program. The constructor of Aiyra's OptionsHandler class has the
following definitions:

#+BEGIN_EXAMPLE
opt.getSet().addOption("f", Options.Separator.BLANK, Options.Multiplicity.ONCE);
opt.getSet().addOption("m", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);
opt.getSet().addOption("p", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);		
#+END_EXAMPLE

=-f=: required field that indicates the file to be parsed;

=-m=: an optional comment about the trace;

=-p=: the plugin to be used by the simulator.

To check if the user has passed the arguments properly, the Options
class provides a simple method thet returns a boolean:

#+BEGIN_EXAMPLE
opt.check
#+END_EXAMPLE

In the OptionsHandler class, this verification is done in the
=checkOptionsHelper= method, which prints a helper text to the user in
case the check fails.

#+BEGIN_EXAMPLE
public void checkOptionsHelper() {
	// true=ignoreUnmatched false=requireLast
	if (!this.opt.check(true, false)) {
		System.out.println("Your input is incorrect");
		System.out.println("Please use the following notation:");
		System.out.println("-f <path-to-filename>");
		System.out.println("-m <comment> (optional)");
		System.out.println("-p <plugin> (optional, default: null) ");
			
		System.exit(1);
	}
}
#+END_EXAMPLE

This validation must be done before the program continues, thus, this
method is already called in the constructor:

#+BEGIN_EXAMPLE
 public OptionsHandler(String args[]) {
	  opt = new Options(args);

      opt.getSet().addOption("f", Options.Separator.BLANK, Options.Multiplicity.ONCE);
      opt.getSet().addOption("m", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);
      opt.getSet().addOption("p", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);

      checkOptionsHelper();	
  }
#+END_EXAMPLE 

* Paje File Format Parser for JavaCC
\label{ap.grammar}
#+BEGIN_EXAMPLE
options
{
  static = false;
}

PARSER_BEGIN(PajeGrammar)
package br.ufrgs.inf.tlbellini;
import br.ufrgs.inf.tlbellini.lib.*;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.ArrayList;
import ml.options.*;
import br.ufrgs.inf.tlbellini.plugins.*;

public class PajeGrammar
{

  public static ArrayList<PajeEventDefinition> eventDefinitions = new ArrayList<PajeEventDefinition>(); 
  public static PajeSimulator simulator = new PajeSimulator();
  public static OptionsHandler options;
 
  public static void main(String args []) throws ParseException, FileNotFoundException
  {
	FileInputStream input;
	Scanner sc = new Scanner(System.in);
	options = new OptionsHandler(args);
	input = null;
    if(args.length > 0)
    {
	input = new FileInputStream(options.opt.getSet().getOption("f").getResultValue(0));
	options.checkEntry();
    }else
    {
      options.checkOptionsHelper();
    }

    simulator.init();
    PajeGrammar parser = new PajeGrammar(input);
          
      try
      {
        switch (parser.paje())
        {
          case 4 :
          simulator.finish();
          System.out.println("OK!");
          case 1 : 
          System.out.println("Goodbye.");
          break;
          default: 
          break;
        }
      }
      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
      }
    }
}

PARSER_END(PajeGrammar)

SKIP :
{
  " "
| "\r"
| "\t"
|  <  "#" (~["\r", "\n"])* ("\n" | "\r\n") >
}

TOKEN:
{
< BREAK: "\n" | "\r\n" >
}

TOKEN : /* EVENT DEFINITION */
{
  < EVENT_DEF_BEGIN : "%EventDef" >
| < EVENT_DEF : "%" >
| < EVENT_DEF_END : "%EndEventDef" >
| < EVENT_DEF_ALIAS : "Alias" >
| < EVENT_DEF_TYPE : "Type" | "ContainerType" | "EntityType" >
| < EVENT_DEF_NAME : "Name" >
| < EVENT_DEF_COLOR: "Color" >
| < EVENT_DEF_START_CONTAINER_TYPE : "StartContainerType" | "SourceContainerType">
| < EVENT_DEF_END_CONTAINER_TYPE : "EndContainerType" | "DestContainerType">
| < EVENT_DEF_CONTAINER : "Container">
| < EVENT_DEF_TIME : "Time">
| < EVENT_DEF_START_CONTAINER : "StartContainer" | "SourceContainer">
| < EVENT_DEF_END_CONTAINER : "EndContainer" | "DestContainer">
| < EVENT_DEF_VALUE : "Value">
| < EVENT_DEF_KEY : "Key">
| < EVENT_DEF_LINE : "Line">
| < EVENT_DEF_FILE : "File">
}

TOKEN :
{
  < EVENT_DEF_FIELD_TYPE_STRING : "string" >
| < EVENT_DEF_FIELD_TYPE_FLOAT : "float" >
| < EVENT_DEF_FIELD_TYPE_DOUBLE : "double" >
| < EVENT_DEF_FIELD_TYPE_INT : "int" >
| < EVENT_DEF_FIELD_TYPE_HEX : "hex" >
| < EVENT_DEF_FIELD_TYPE_DATE : "date" >
| < EVENT_DEF_FIELD_TYPE_COLOR : "color" >
}

TOKEN :
{
   < PAJE_DEFINE_CONTAINER_TYPE : "PajeDefineContainerType" >
 | < PAJE_DEFINE_VARIABLE_TYPE : "PajeDefineVariableType" >
 | < PAJE_DEFINE_STATE_TYPE : "PajeDefineStateType" >
 | < PAJE_DEFINE_EVENT_TYPE : "PajeDefineEventType" >
 | < PAJE_DEFINE_LINK_TYPE : "PajeDefineLinkType" >
 | < PAJE_DEFINE_ENTITY_VALUE : "PajeDefineEntityValue" >
}

TOKEN :
{
   < PAJE_CREATE_CONTAINER : "PajeCreateContainer" >
 | < PAJE_DESTROY_CONTAINER : "PajeDestroyContainer" >
}

TOKEN :
{
   < PAJE_SET_VARIABLE : "PajeSetVariable" >
 | < PAJE_ADD_VARIABLE : "PajeAddVariable" >
 | < PAJE_SUB_VARIABLE : "PajeSubVariable" >
}

TOKEN :
{
   < PAJE_SET_STATE : "PajeSetState" >
 | < PAJE_PUSH_STATE : "PajePushState" >
 | < PAJE_POP_STATE : "PajePopState" >
 | < PAJE_RESET_STATE : "PajeResetState" >
}

TOKEN :
{
   < PAJE_START_LINK : "PajeStartLink" >
 | < PAJE_END_LINK : "PajeEndLink" >
 | < PAJE_NEW_EVENT : "PajeNewEvent" >
}


TOKEN :
{
  < INT : (< DIGIT >)+ >
| < FLOAT : (< DIGIT >)+"."(< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
| <STRING: "\"" (<LETTER> | < DIGIT > |  " ")* "\"" | (<LETTER> | <DIGIT>)+>
| <CHAR : (~["\""] | "\\" (["n","r","\\","\'","\""])) >
| < #LETTER : ["a"-"z", "A"-"Z", "-", "_", "."]  >
}

int paje() throws Exception:
{}
{
  declarations() events() < EOF >
  {
    return 4;
  }
  
}

void declarations() :
{PajeEventDefinition newDef;}
{
  (
    newDef = declaration()
  	{eventDefinitions.add(newDef);}
  )*

}

void empty():
{}
{
  < EOF >
}

PajeEventDefinition declaration():
{
  PajeEventId nameId;
  int id;
  ArrayList<PajeField> fieldsList;
}
{
	< EVENT_DEF_BEGIN > nameId = event_name() id = event_id() < BREAK >
	{ PajeEventDefinition def = new PajeEventDefinition(nameId, id); }
	fieldsList = fields() < EVENT_DEF_END > < BREAK >
	{
	 	def.addFields(fieldsList);
	 	return def;
	 }
}

PajeEventId event_name():
{}
{
  	< PAJE_DEFINE_CONTAINER_TYPE > { return PajeEventId.PajeDefineContainerType;} |
	< PAJE_DEFINE_VARIABLE_TYPE > {return  PajeEventId.PajeDefineVariableType;} |
	< PAJE_DEFINE_STATE_TYPE > { return PajeEventId.PajeDefineStateType;} |
	< PAJE_DEFINE_EVENT_TYPE > { return PajeEventId.PajeDefineEventType;} |
	< PAJE_DEFINE_LINK_TYPE >{ return PajeEventId.PajeDefineLinkType;} |
	< PAJE_DEFINE_ENTITY_VALUE >{ return PajeEventId.PajeDefineEntityValue;} |
	< PAJE_CREATE_CONTAINER >{ return PajeEventId.PajeCreateContainer;} |
	< PAJE_DESTROY_CONTAINER >{ return PajeEventId.PajeDestroyContainer;} |
	< PAJE_SET_VARIABLE >{ return PajeEventId.PajeSetVariable;} |
	< PAJE_ADD_VARIABLE >{ return PajeEventId.PajeAddVariable;} |
	< PAJE_SUB_VARIABLE >{ return PajeEventId.PajeSubVariable;} |
	< PAJE_SET_STATE >{ return PajeEventId.PajeSetState;} |
	< PAJE_PUSH_STATE >{ return PajeEventId.PajePushState;} |
	< PAJE_POP_STATE >{ return PajeEventId.PajePopState;} |
	< PAJE_RESET_STATE >{ return PajeEventId.PajeResetState;} |
	< PAJE_START_LINK >{ return PajeEventId.PajeStartLink;} |
	< PAJE_END_LINK >{ return PajeEventId.PajeEndLink;} |
	< PAJE_NEW_EVENT >{ return PajeEventId.PajeNewEvent;}
}
int event_id():
{Token value;}
{
  value = < INT > { return Integer.parseInt(value.image); }
}

 ArrayList<PajeField> fields():
{ ArrayList<PajeField> fieldsList = new ArrayList<PajeField>();
  PajeField newField; }
{
  (
    newField = field()
    {
     	fieldsList.add(newField);
   	}
  )*
  {return fieldsList;}
}

PajeField field():
{
  	PajeField newField = new PajeField();
 	PajeFieldName newFieldName;
	PajeFieldType newFieldType;
}

{ 
  < EVENT_DEF > newFieldName = field_name() newFieldType = field_type()
  {
    newField.setField(newFieldName);
  	newField.setType(newFieldType);
  }
  < BREAK >
  {return newField;}
}

PajeFieldName field_name() :
{}
{
  
< EVENT_DEF_ALIAS >{ return PajeFieldName.Alias; } |
	< EVENT_DEF_TYPE >{ return PajeFieldName.Type; } |
	< EVENT_DEF_NAME >{ return PajeFieldName.Name; } |
	< EVENT_DEF_COLOR >{ return PajeFieldName.Color; } |
	< EVENT_DEF_START_CONTAINER_TYPE >{ return PajeFieldName.StartContainerType; } |
	< EVENT_DEF_END_CONTAINER_TYPE >{ return PajeFieldName.EndContainerType; } |
	< EVENT_DEF_CONTAINER >{ return PajeFieldName.Container; } |
	< EVENT_DEF_TIME >{ return PajeFieldName.Time; } |
	< EVENT_DEF_START_CONTAINER >{ return PajeFieldName.StartContainer; } |
	< EVENT_DEF_END_CONTAINER >{ return PajeFieldName.EndContainer; } |
	< EVENT_DEF_VALUE >{ return PajeFieldName.Value; } |
	< EVENT_DEF_KEY >{ return PajeFieldName.Key; } |
    < EVENT_DEF_LINE >{ return PajeFieldName.Line; } |
    < EVENT_DEF_FILE >{ return PajeFieldName.File; } |
	< STRING >{ return PajeFieldName.Extra;}
}

PajeFieldType field_type():
{}
{
	< EVENT_DEF_FIELD_TYPE_STRING >{ return PajeFieldType.PAJE_string; } |
	< EVENT_DEF_FIELD_TYPE_FLOAT >{ return PajeFieldType.PAJE_float; } |
	< EVENT_DEF_FIELD_TYPE_DOUBLE >{ return PajeFieldType.PAJE_double; } |
	< EVENT_DEF_FIELD_TYPE_INT >{ return PajeFieldType.PAJE_int; } |
	< EVENT_DEF_FIELD_TYPE_HEX >{ return PajeFieldType.PAJE_hex; } |
	< EVENT_DEF_FIELD_TYPE_DATE >{ return PajeFieldType.PAJE_date; } |
	< EVENT_DEF_FIELD_TYPE_COLOR >{ return PajeFieldType.PAJE_color; }
}

void events() throws Exception:
{}
{
  (event())*
}

void event() throws Exception:
{}
{
	non_empty_event() | < BREAK >
}

void non_empty_event() throws Exception:
{
	PajeTraceEvent event = new PajeTraceEvent();
 	Token id; 
}
{
  id = < INT >
  {
  	ArrayList<String> fields;
  	event.setPajeEventDef(Integer.parseInt(id.image), eventDefinitions);
  	event.setLine(id.beginLine); 
  } 
  fields = arguments() <  BREAK >
  {
  	event.setFields(fields);
  	simulator.simulate(event);
  }
}

ArrayList<String> arguments():
{
	ArrayList<String> fields = new ArrayList<String>();
	String field;
}
{
  (
  	field = argument()
  	{
  		fields.add(field);
  	} 
  )*
  {return fields;}
}

String argument():
{	Token arg;
}
{
	arg = < STRING > {return arg.image.toString();}
	|arg = < FLOAT > {return arg.image.toString();}
	|arg = < INT > {return arg.image.toString();}

} 
#+END_EXAMPLE


* How to execute aiyra
\label{ap.aiyraexecute}

Clone the repository in [[https://github.com/taisbellini/aiyra]].

To compile aiyra navigate to the *workspace* folder and execute the
command =source compile.sh=.  It will give you information about the
usage.

To execute it perform the following command:
  
#+BEGIN_EXAMPLE
java br.ufrgs.inf.tlbellini.PajeGrammar -f <path to input Paje tracefile> -p <plugin> <option> <argument> ...
#+END_EXAMPLE

As arguments, you have the following options:
#+BEGIN_EXAMPLE
-f <path-to-filename>
-m <comment> (optional)
-p <plugin> (optional, default: null) 
The available plugins and its respective inputs are as follows: 
pjdump: PajeDump - dumps the data
-l <number-of-lines> (optional): number of lines per dump if pjdump chosen, default: 100000
mysql: MYSQL Database - sequential batches - insert data into a database using batches
-s <server-name> (optional): server name for the database. Default: localhost
-u <user-name> (optional): username to access database. Default: root
-pwd <password> (optional): password to access database. Default: root
-batch <max_size> (optional): Maximum size of batch to keep in memory
#+END_EXAMPLE

If you wish to use the *PajeInsertDBPlugin*, the database is described
by the script =pajeDB.sql= in Aiyra's main folder. Execute this plugin
in a connection in MySQL and provide the parameters for the host,
username and password.

* How to create a plugin

To create a plugin, extend the *PajePlugin* class and override the
abstract methods. The objects available for the plugin are described
in section \ref{section.plugin}.  If you wish to add arguments to your
plugin, refer to the Appendix \ref{ap.optionshandler}.
