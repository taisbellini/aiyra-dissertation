#+TITLE: 
#+AUTHOR: Tais Bellini

#+STARTUP: overview indent
#+LANGUAGE: en
#+OPTIONS: H:3 creator:nil timestamp:nil skip:nil toc:nil num:t ^:nil ~:~
#+OPTIONS: author:nil title:nil date:nil
#+TAGS: noexport(n) deprecated(d) ignore(i)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+LATEX_CLASS: iiufrgs
#+LATEX_CLASS_OPTIONS: [times,cic,tc,english]
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{subfigure}
#+LATEX_HEADER: \usepackage{tabulary}
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{algorithmic}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \newcommand{\prettysmall}{\fontsize{6.5}{6.5}\selectfont}
#+LATEX_HEADER: \newcommand{\prettysmallbis}{\fontsize{7}{7}\selectfont}
#+LATEX_HEADER: \newcommand{\mtilde}{~}

#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{palatino}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{cleveref}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage[normalem]{ulem}
#+LATEX_HEADER: \usepackage{xspace}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \graphicspath{{img/}{img/final/}}
#+LATEX_HEADER: \hypersetup{hidelinks = true}

#+LATEX_HEADER: \newcommand{\review}[1]{\textcolor[rgb]{1,0,0}{[Lucas: #1]}}
#+LATEX_HEADER: \newcommand{\lucas}[1]{\textcolor[rgb]{0.2,0.2,0.7}{[Lucas: #1]}}
#+LATEX_HEADER: \input{configuration.tex}


#+BEGIN_LaTeX
\title{TCC da Tais}
\author{Loureiro Bellini}{Tais}
\advisor[Prof.~Dr.]{Mello Schnorr}{Lucas}

\date{Junho}{2016}
\location{Porto Alegre}{RS}

% \renewcommand{\nominataReit}{Prof\textsuperscript{a}.~Wrana Maria Panizzi}
% \renewcommand{\nominataReitname}{Reitora}
% \renewcommand{\nominataPRE}{Prof.~Jos{\'e} Carlos Ferraz Hennemann}
% \renewcommand{\nominataPREname}{Pr{\'o}-Reitor de Ensino}
% \renewcommand{\nominataPRAPG}{Prof\textsuperscript{a}.~Joc{\'e}lia Grazia}
% \renewcommand{\nominataPRAPGname}{Pr{\'o}-Reitora Adjunta de P{\'o}s-Gradua{\c{c}}{\~a}o}
% \renewcommand{\nominataDir}{Prof.~Philippe Olivier Alexandre Navaux}
% \renewcommand{\nominataDirname}{Diretor do Instituto de Inform{\'a}tica}
% \renewcommand{\nominataCoord}{Prof.~Carlos Alberto Heuser}
% \renewcommand{\nominataCoordname}{Coordenador do PPGC}
% \renewcommand{\nominataBibchefe}{Beatriz Regina Bastos Haro}
% \renewcommand{\nominataBibchefename}{Bibliotec{\'a}ria-chefe do Instituto de Inform{\'a}tica}
% \renewcommand{\nominataChefeINA}{Prof.~Jos{\'e} Valdeni de Lima}
% \renewcommand{\nominataChefeINAname}{Chefe do \deptINA}
% \renewcommand{\nominataChefeINT}{Prof.~Leila Ribeiro}
% \renewcommand{\nominataChefeINTname}{Chefe do \deptINT}


% \keyword{formatação eletrônica de documentos}
% \keyword{\LaTeX}
% \keyword{ABNT}
% \keyword{UFRGS}



\maketitle



#+END_LaTeX

                                                      
# #+BEGIN_LaTeX
# \begin{abstract}
# #+END_LaTeX


# #+BEGIN_LaTeX
# \end{abstract}
# #+END_LaTeX


* Configuring Emacs to correctly export to PDF			   :noexport:

Org mode is configured by default to export only the base classes.

See for details:
+ http://orgmode.org/worg/org-tutorials/org-latex-export.html

Execute the following code (with C-c C-c) prior to export this file to PDF.

#+BEGIN_SRC emacs-lisp :results silent :exports none
(add-to-list 'org-latex-classes
             '("iiufrgs"
               "\\documentclass{iiufrgs}"
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC
* 2016-03-18 First entry (proper emacs configuration file)   :noexport:Lucas:

I recommend you use Arnaud's emacs configuration file, available here:
+ http://mescal.imag.fr/membres/arnaud.legrand/misc/init.php

Download the file =init.org=:

#+begin_src sh :results output :session :exports both
wget http://mescal.imag.fr/membres/arnaud.legrand/misc/init.org
#+end_src

#+RESULTS:

* 2016-04-29 How to compile with _bibtex_ entries              :Lucas:noexport:

Do as follows:

1. Export as usual to latex
2. Then, type in the terminal
   #+begin_src sh :results output :session :exports both
   pdflatex Dissertation.tex
   bibtex Dissertation
   pdflatex Dissertation.tex
   pdflatex Dissertation.tex
   #+end_src

* Introduction
Observation of program behavior is particularly important in High
Performance Computing since it enables an accurate performance
analysis. A very common method of evaluation is registering program
events in trace files that work as a log, so, whenever a relevant
event happens, it will be logged in the trace file with the proper
information. Then, these traces are replayed in simulation combining
information that is spread across multiple events deriving new and
richer entities \cite{XXX}. This event processing is usually done once
and discarded, which can be very inconvenient considering that some
trace files are very large. Therefore, it would be interesting to save
these entities for further analysis.

In this context of performance analysis, a common tool used is the
Pajé Trace Simulator \cite{kergommeaux2000paje}, an open source
project that reads trace files in a specific format, the Pajé Trace
File Format \cite{pajetracefile}, and processes five types of
entities: Containers, States, Events, Variables and Links. These
concepts represent basic structures of computer programs executed in
parallel or distributed systems, such as processes, threads, network
links, hardware counters and so on. As a base for the implementation
of this proposal, the new generation of Pajé, PajeNG \cite{pajeng},
was used. Details of PajeNG, the types of entities and the Pajé File
Format will be presented in Chapter \ref{chapter.paje}. Although it
has a visualization functionality, we will focus on the simulation
part of the Pajé implementation in this project. The most commonly
used tool of PajeNG is the Pajé Dump (=pj_dump=) \cite{XXX}, that
dumps to the standard output all information regarding entities
created throughout the simulation.

There are at least three problems with the current implementation of
Pajé: little extensibility, lack of partial outcomes and impermanent
results. The original Pajé and, consequently, its next generation were
idealized and built in an extensible way, that could be easily
expanded based on the user's needs. Although the implementation is
very modular, it is necessary to write a full component for Pajé,
which is a complex thing because it implies in understanding the
internal objects, class hierarchy, protocol, and so on. Until now,
very few people have actually extended this tool. Throughout the
simulation, the Pajé tool creates entities according to the events
listed in the trace file, saving each one of them in memory to dump
everything at once in the end. Since some trace files can be very
large (over 1 Gigabyte), it may take a while for the results to be
printed out. Besides not being able to have a partial view of already
simulated entities, the user won't have records of the results between
executions for different files unless he specifies a destination for
it himself. To address these issues, an extensible trace files
simulator, Aiyra, was developed in Java.

The objective of this proposal is to allow the performance analyst to
change the simulator behavior when a new entity is detected. Thus, the
partial results can be immediately presented to the user, or saved in
a database, or even discarded if not relevant. This extensibility is
implemented through the concept of plugins that are attached to the
simulator in specific and important points where the trace events are
combined. This main objective solves the lack of extensibility
problem. Once the simulator allows the immediate manipulation of the 
entities, the other two issues can be easily addressed with
extensions. Hence, the secondary objectives of the project are the 
creation of plugins to dump partial data that has just been simulated 
and to make the results permanent.

For the validation of the extensible trace files simulator, two
plugins were implemented: Paje Dump Plugin and Paje Insert Database
Plugin. The first one plays the same roll as the original Paje Dump
tool in the Paje new generation, with the difference that the entities
are dumped at the moment they are completed. The second one inserts
all the data in a relational database. A specific schema for the Pajé
Format was designed and will be presented in Chapter
\ref{chapter.plugins}.  A performance analysis was developed to
compare Aiyra against the previous one. It is worth highlighting that
the new simulator had better performance results with bigger files
(over 120 Megabytes), that being possibly attributed to the fact that
it discards from memory entities that will no longer be
used. Additionally, the Pajé Insert Database plugin was evaluated
comparing its different possibilities of usage. In this investigation,
we varied the frequency of the insertions in the database by grouping
queries in memory until it had a specific size to insert. The
objective of this test was to understand the impact of an access to a
database in the performance of the program. Likewise, the usage of the
memory was also examined to determine the best balance between
execution time and memory management. As we will see in Chapter 6, the
memory usage had more impact in the performance than the accesses to
the database themselves, probably due to the Garbage Collector
mechanism used by Java.

This document is organized as follows. Chapter
\ref{chapter.basic_concepts} provides the basic concepts of the
technologies used throughout the project.  Chapter \ref{chapter.paje}
gives an overview of the existing simulator for the Pajé format and
the problems with this current implementation. Chapter
\ref{chapter.aiyra} describes the details of the extensible simulator
developed in Java and Chapter \ref{chapter.plugins} characterize the
plugins developed. Chapter \ref{chapter.performance} presents a
performance analysis of the Pajé Insert Database Plugin and a
comparison between Aiyra and PajeNG.  The conclusion and final
considerations are expressed in Chapter \ref{chapter.conclusion}.

* Basic Concepts
\label{chapter.basic_concepts}

This chapter describes the basic notions of the concepts and
technologies used to develop this project. They contribute to the
understanding of our work. It is structured in five topics: the Java
Compiler Compiler (JavaCC), the Java Database Connectivity (JDBC) API
in the MySQL context, a brief description about the construction of
conceptual and logical database schemas, an overview about
experimental design, and the R language in the experimental design
context.

** The Java Compiler Compiler (JavaCC) tool
\label{section.javacc}

The Java Compiler Compiler (JavaCC) is a lexical and parser generator
configured with a set of regular expressions describing the tokens of
a language and a grammar using these tokens. As output, it generates a
lexical and syntax parser in the Java language. The lexical code
separates the input file into tokens; the parser code is responsible
for the syntax analysis.

What differentiates JavaCC from other parser generators that exist for
the Java language is that it creates source code in Java. This
facilitates the understanding and eliminates the need of having
dependencies in the code. JavaCC has also shown itself to have a much
better performance than other tools such as Another Tool For Language
Recognition (ANTLR), that requires a runtime library
\cite{javaccversusantlr}. ANTLR was our first choice of parser
generator, but it was soon discarded due to its very low performance.

JavaCC can be downloaded, unzipped and added to the PATH. It also has
a plugin for Eclipse. Figure \ref{fig.javaccex} exemplifies how JavaCC
works. Once installed, JavaCC processes your grammar defined in a file
with extension ``.jj'' using the command =javacc=. The whole grammar
is kept in this file and it is the only file that needs to be
modified. It is also possible to add Java code that has to be executed
during the parsing.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{How JavaCC works}
\centering
\includegraphics[width=\linewidth]{./img/ermodelex.png}
\label{fig.javaccex}
\end{figure}
#+END_LaTeX

In Figure \ref{fig.javaccex} we can see an example of the processing
of a file named *MyGrammar.jj*, which results in seven files: the
parser in *MyGrammar.java*; the lexical analyser in
*MyGrammarTokenManager.java* and some useful constants in
*MyGrammarConstants.java*.  The other four files generated:
*Token.java*, *TokenMgrError.java*, *SimpleCharStream.java* and
*ParseException.java* are boilerplate files that can be reused within
parsers and are not affected by the grammar itself.  The corresponding
Java source code for the scanner and parser can be compiled as usual
with =javac=.

** JDBC and MySQL

The Java Database Connectivity (JDBC) API is a standard for
connectivity between Java and a range of relational databases
\cite{jdbc}. It comprises methods to query and update data, enabling
the Java language to interact with several Database Management Systems
(DBMS) in a standard manner. This API facilitates the migration from
one database tool to another and unbounds your application from a
DBMS.

The JDBC architecture consists in two layers: JDBC API and JDBC Driver
API. JDBC can support multiple heterogeneous databeses \cite{jdbctut}
by using drivers connected to them. The JDBC Driver API manages these
drivers to ensure that the correct one is being used. The JDBC API
layer, in turn, administrates the communication between the
application and the driver manager. JDBC API consists in classes and
interfaces, such as *DriverManager*, which makes a connection between
requests from the application and the proper database driver;
*Connection*, containing all the methods necessary to contact the
database; *Statement*, that creates objects that will be submited to
the database; and *ResultSet*, where the retrieved objects are placed.

Among the possible DBMS that can be used in a Java application using
JDBC is the MySQL system, one of the most important open-source DBMS
in the market. It has been developed by Oracle and uses SQL language
as interface. To enable the use of MySQL with Java, Oracle provides a
driver for JDBC, as well as a native C library to allow developers to
embed SQL commands directly in the application's code.

_Comment_: *Better? bigger or wipe it?*

** Entity-Relationship and Relational Models
\label{subsection.er_relational}

An Entity-Relationship (ER) model defines a database in a conceptual
view \cite{heuser}. This model can be represented by an ER Diagram
(ERD), illustrated in Figure \ref{fig.ermodelex}, and can be denoted
by *schema*. It is based in the notion of *entities*, which can be
real-world objects that are easily identifiable \cite{ertutorial}, and
the *relationship* between them. The entities have a set of
attributes, where one or more are defined as the *identifier*, which
uniquely identify an object of that entity. It is also possible for a
relationship to have attributes, like the *Address* attribute in
Figure \ref{fig.ermodelex}. Besides, an entity can derive other more
specialized entities, which is called *specialization*.

A relationship between entities *A* and *B* can have one of the
following patterns: *one-to-one*, where an object of the entity A can
be associated to only one of type B and vice versa; *one-to-many*,
which means that an instance of the entity A can be associated to more
than one entities of type B, but B entities can only relate to at most
one of type A; *many-to-many*, where one object from the A entity can
be associated to more than one entities of type B and vice
versa. These characteristics also apply to self-referencing relations,
where there is a relationship of an entity with itself. Besides, a
connection can be an *identifying relationship*, which means that the
relationship identifies an object. In Figure \ref{fig.ermodelex} we
can see the example of the relationship between a *City* and a
*State*, where we define that a state can have more than one city,
while a city belongs to only one state. Also, the state identifies a
city along with its name, since there can be other cities with the
same name but in different states. In these cases the entity is called
a *weak entity*.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Example of ER Model}
\centering
\includegraphics[width=\linewidth]{./img/ermodelex.pdf}
\label{fig.ermodelex}
\end{figure}
#+END_LaTeX

The ER Model is an overview of the structure of a database. To evolve
to the implementation, a translation to a Relational Model must be
performed. The ER model is a conceptual description of the database,
while the relational model is a logical representation
\cite{heuser}. Relational databases are based in the concept of
*tables* \cite{relationalmodel}, thus, the terminology used in this
step involves *tables*, *rows* (or *tuples*) and *columns*. The
identifier is called *primary key*. There are a set of rules to make
this translation, although sometimes it is necessary to adapt the
schema based on the user's needs.

The *entities* of the ER model become *tables* in the relational
model, while its attributes become the *columns* of the tables. Each
instance of an entity is a row and its identifier can be one or more
columns that compose the *primary key*. When there is an identifying
relationship, the weak entity attaches the identifier of the other
entity to its own primary key. A *one-to-one* relationship generates a
merge of both tables involved. *One-to-many* links adds an attribute
in one of the tables. The entity that can only be related to one of
the instances of the other receives the attribute, which is called
*foreign key*. It also absorbs the attributes of the relationship. In
the example of figure \ref{fig.ermodelex}, the table referencing the
*School* entity would have the *stateName* and *cityName* (the primary
key of City) as foreign keys and *address* as attribute. The foreign
key is what preserves the link between two entities. *Many-to-many*
relationships have to be represented by a separate table with the
primary keys of both entities involved, which also work as foreign
keys. In our illustration, the relationship between *Grade* and
*Student* would become a table, with *studentId* and *gradeId* as
primary and foreign keys.

The translation of specializations can be made in two ways: one single
table for all of the hierarchy, where the primary key would be the
identifier of the most generic entity and there would be optional
columns; and one table for each specialized entity, where all of them
would have the identifier of the most generic entity composing the
primary key. The first case, in Figure \ref{fig.ermodelex}, would
generate a single *Person* table, with *personId* as primary key and
*name*, *phone*, *studentId*, *course* and *salary* as attributes. In
the second option, *Student* and *Teacher* become tables, with
*personId* composing their primary key.

** Experimental Design

Experimental design, in the context of performance analysis, aims to
define a minimum number of experiments that collects the maximum
information necessary \cite{jain}. It also targets random variations
that could affect the results, guaranteeing that the number of tests
executed and the error margin calculated is sufficient to avoid
misleading conclusions.

There is a specific terminology used in experimental design. The term
*Response Variable* is the outcome of an experiment; *Factors* are all
of the variables that can have several different values affecting the
response variable, and *Levels* are the possible values that a factor
can assume. Also, the *Primary Factors* are the factors that need to
be quantified, *Secondary Factors* are the factors whose impacts in
the performance are irrelevant for the analysis, *Replication* is the
number of repetition of all or some experiments and *Design* is the
specification of total number of experiments based on factor level
combination and number of replications for each experiment. The
*Experimental Unit* is the entity used for the experiment, which could
be a computer, for example, and *Interaction* is when the levels of a
fator affect the results of other factor.

There are several types of experimental design modeling. One of them
is the full factorial design, which consists in evaluating every
possible combination at all levels of all factors. With this type of
design, it is possible to measure factors with multiple numbers of
levels. The advantage of this model is that every possible combination
is measured, generating richer results. However, depending on the
number of factors, levels and replications, it may generate too many
experiments, which can cost a lot of time. Therefore, when using this
technique, it is important to weight the relevance of each factor and
level to generate an appropriate and accurate design. To calculate the
total size of the sample you multiply the numbers of levels of the
factors and the number of replications. For example, a design with a
three-level factor, a two-level factor and 20 replications would have
120 experiments (the result of $3*2*20$).

When there are too many factors and levels, it may not be possible to
use the full factorial design. In these cases, one can use a
fractional factorial design, which covers just a fraction of the full
factorial design. In this type of experiment, a carefully chosen
subset of factors and levels is taken into consideration, based on the
most important features the analyser wants to test. Although it saves
time and expenses, the results provide less information.


** The R language

R is a language for statistical computing and graphics generation. It
can be very easily extended, by creating and using packages. With R,
it is possible to create full factorial or fractional designs using
the =DoE.base= package. It contains the class =design= with several
accessor functions to create different types of design. One particular
important function is the =fac.design=, which creates full factorial
designs with an arbitrary numbers of levels. The function receives
several arguments, including number of factors, levels and
replication. The usage of the function is the following:
#+BEGIN_LaTeX
\begin{lstlisting}
require(DoE.base);
fac.design(
  nfactors=2,
  replications=30,
  repeat.only=FALSE,
  blocks=1,
  randomize=TRUE,
  seed=10373,
  nlevels=(3,6),
  factor.names= list(
                input=c("small", "medium", "big"),
                batch=c("A", "B", "C", "D", "E", "F")));
\end{lstlisting}
#+END_LaTeX
where =nfactors= represents the number of factors, =replications= is
the number of replications, =repeat.only= tells if the replications of
each run are grouped together, =blocks= is a prime-number telling in
how many blocks the experiment is subdivided, =randomize= informs the
design is randomized, =seed= is the optional seed for the
randomization, =nlevels= is a vector with the number of levels for
each factor and =factor.names=: a list of vectors with factor levels.
This example is one of the designs used for the performance evaluation
in Chapter \ref{chapter.performance}.


* Pajé Visualization Tool - PajeNG 
\label{chapter.paje}

The Pajé Visualization Tool is an implementation to display the
execution behavior of parallel and distributed programs. It reads
information from trace files that describe the important events during
the execution of a program and replays them through simulation.  It
has been developed to simulate trace files in the Pajé Trace File
Format, thus, it is important to understand how the Pajé trace files
are composed. Section \ref{section.pajeformat} describes this format
and all entity types it contains. The next section describes the new
generation of the Pajé Visualization Tool, the PajeNG, focusing on the
=libpaje= module, which is where the core simulation is performed.
 
** Pajé Trace File Format
\label{section.pajeformat}

_Comment_
- A figure C1 - C2, T1, T2 where you have on the left the type
  hierarchy and on the right the entities hierarchy. Align the levels
  of such hierarchies with dashed lines showing the
  correspondance. Pay attention to timestamped objects (you may
  represent horizontally).

This section gives an overview of the Pajé Trace File Format and its
complete description is in Appendix \ref{ap.pajeformat}. The Pajé
Trace File Format \cite{pajetracefile} is a textual and generic
pattern that describes the behaviour of parallel and distributed
programs. The Pajé format describes five types of entities:
containers, states, events, variables and links. Each entity is always
associated to a container, even the containers themselves. A
*container* can be any hardware or software entity, such as a
processor, a thread, a network link, etc. It is the only Pajé object
that holds other objects, including containers, which makes it the
main component to define the type hierarchy. A *state* is used to
describe periods of time where a container stays at the same state,
like a thread that is blocked, for example. It always has a beginning
and an ending timestamps. An *event* has only one timestamp, and can
be anything noteworthy to be uniquely identified. A *variable* entity
represents the progression of a variable's value along time. It is
represented by an object with a value and two timestamps, beginning
and end, indicating how long the variable had that specific value. A
*link* represents a relationship between two containers, such as a
communication between processes. It contains two timestamps specifying
the beginning and the end of the communication. A Pajé trace file is
divided in two segments: event definition and timestamped events,
which are described below.

*Events Definition* 

The first part of a trace file describes all of the possible events of
the trace. This part is composed by a block where the first line
contains the name of the event, like =PajeDefineContainerType=, for
example, followed by a unique identifier. The identifier is what will
be used later by the events to determine the type of event in
question. After, there is a set of fields, one in each line. Each
field comprises a name, and a type. The type of a filed can be a
=string=, =double=, =int=, =date=, =hex= or =color=.

*Events*
\label{subsection.events} 

After the events definition, the events themselves are described, one
in each line. Every event starts with its identifying number, which
was defined previously, followed by the fields separated by space or
tab. Before the entities, such as states or links, can be created, a
hierarchy of types and containers must be defined and containers need
to be instantiated, since every entity belongs to a container. There
are sets of events associated to each kind of entity described above,
besides the events that define entity types.

The Pajé objects are organized in two separated hierarchies: types and
entities. These hierarchies are specific for each trace file, although
it can be repeated in traces with the same scenario. In the structure
of the trace file, the type hierarchy comes just after the event
definition. There, each type of the program is defined and one of the
fields is always the parent type. Each entity is always associated to
a type and they must follow the same precedence as the types
definition. For example, if the container C1, of type T1, is the
parent of the container C2, of type T2, the type T2 must be child of
T1 in the type tree. The root type is always the number $0$. The
difference between both hierarchies relies on the number of nodes:
while the type hierarchy has only a few, the entities hierarchy may
have millions depending on the number of containers in the trace.

(image)

Type definition events don't have a timestamp field and can occur at
anytime in a trace file, as long as the type is not used before its
definition. It is more common to have all the types defined in the
beginning. The events associated to the containers are timestamped and
can create or destroy instances during the trace file. A container
cannot be referenced after it was destroyed. Variables can be set at a
specific timestamp and have its value changed throughout the
simulation by addition and subtraction events. The value of a variable
is a double precision floating-point number, which is different from
the values of the other entities. A variable must be set before
changes to its value can be made.

** PajeNG
\label{section.pajeng}

The PajeNG implementation is the new generation of the Pajé
Visualization Tool \cite{pajeng}. It was developed in C++ and follows
the same architecture as the original Pajé, written in Objective-C. It
comprises a library containing the core of the simulation (=libpaje=),
a space-time visualization tool and some auxiliary tools to manage the
trace files. The base for the implementation of this project was the
=libpaje= library.

The library, represented in Figure \ref{fig.pajeparco} has three main
components forming a pipeline that results in complete simulated
entities. These components are: =FileReader=, =EventDecoder= and
=PajeSimulator=. First, the =FileReader= reads a chunk of data from
the trace file and puts it in memory. Then, the =EventDecoder= breaks
it into events identifying, line by line, the event's fields and
creating an object with all the necessary information. Last, the
=PajeSimulator= receives this event object and addresses to the proper
simulation. An illustration of this process is in figure
\ref{fig.pajeparco}.


#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{PajeNG Architecture [inspired in \cite{kergommeaux2000paje}]}
\centering
\includegraphics[width=\linewidth]{./img/pajeparco.pdf}
\label{fig.pajeparco}
\end{figure}
#+END_LaTeX

Pajé was idealized to be extensible, specially in terms of creating
new types of events. Actually, the Pajé format itself is very
expandable, which makes it necessary to build a simulator
accordingly. This flexibility is implemented by a class hierarchy,
going from the most general, containing the basic fields common to
every type and entity, to the most specific. Besides, the PajeNG tool
supports extra fields in the events, which allows the simulation of
extended entities. There are three main class hierarchies that are
particularly important in this objective: one for events, one for
types and one for entities. With this modular implementation, it is
relatively easy to add a new type of event or entity and integrate it
with the rest of the code.

*Class Hierarchy for Paje Events*

An event object is what is passed as an argument to the simulator so
that it can be processed. Therefore, it must contain all of the
necessary information for the simulation. The first object created
when a trace file is being parsed is of type =PajeTraceEvent=, which
is a class containing all the fields read by the
=PajeEventDecoder=. As depicted in Figure \ref{fig.eventsHierarchy},
the event hierarchy starts with a simple =PajeEvent= class. This class
has a trace event object, a container, a type and a timestamp. The
immediate childs of PajeEvent are: =PajeCategorizedEvent=,
=PajeVariableEvent= and =PajeDestroyContainerEvent=. The variable
event is the parent of the specific events for variables, which are
set, add and subtract. A categorized event is characterized by having
a =PajeValue= associated to it, thus, =PajeStateEvent=,
=PajeEventEvent=, =PajeLinkEvent=, and their respective childs inherit
from it.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Events class hierarchy}
\centering
\includegraphics[width=\linewidth]{./img/eventsHierarchy.pdf}
\label{fig.eventsHierarchy}
\end{figure}
#+END_LaTeX


*Class hierarchy for the Paje Types*

Figure \ref{fig.typesHierarchy} portrays the type hierarchy, where the
first element is the =PajeType=. It has a name, an alias and a parent
type, which is also a PajeType. These fields are the ones common to
all the type definition events described in section
\ref{section.pajeformat}. The immediate childs of this class are:
=PajeCategorizedType=, =PajeVariableType= and =PajeContainerType=. As
the events, the categorized types are associated to a value, hence,
the PajeCategorizedType has a PajeValue field and methods to
manipulate it. Its childs are the =PajeStateType=, =PajeEventType= and
=PajeLinkType=.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Events class hierarchy}
\centering
\includegraphics[width=.6
\linewidth]{./img/typesHierarchy.pdf}
\label{fig.typesHierarchy}
\end{figure}
#+END_LaTeX

*Class hierarchy for the Paje Entities*

As demonstrated in Figure \ref{fig.entitiesHierarchy}, the
=PajeEntity= is the first node of the entities tree. It originates a
=PajeSingleTimedEntity= class, that describes entities with one single
timestamp. The =PajeUserEvent= is the only entity with this
characteristic, but it is possible to add, in the future, more
entities with just one timestamp. The =PajeDoubleTimedEntity= inherits
from this class and represents entities with start and end
timestamps. Like the other hierarchies, the valued entities are
grouped together so a =PajeValuedEntity= is a child of the double
timed entity, having =PajeUserState= and =PajeUserLink= as
descendents. The double timed entity also has =PajeUserVariable= and
=PajeNamedEntity= as childs. A =PajeContainer= inherits from the named
entity.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Entities class hierarchy}
\centering
\includegraphics[width=\linewidth]{./img/entitiesHierarchy.pdf}
\label{fig.entitiesHierarchy}
\end{figure}
#+END_LaTeX

*The Core Simulator*

All the simulation is performed in two classes: =PajeSimulator= and
=PajeContainer=. A PajeSimulator object is instantiated in the
beginning of the program and incorporates all the event processing of
the simulation. The type definitions, container creations and entity
value declarations are completed and stored in the PajeSimulator
object. Every time there is an event of type =PajeCreateContainer=, a
PajeContainer object is instantiated. All other events are always
associated to a container, thus, they will be simulated in the
appropriate container instance. The PajeContainer object will keep the
entities until the program finishes. Since all the data from the
simulation is kept in memory, the end timestamp is used to signal
that an entity no longer can be referred.

The PajeSimulator class lists every type declared and container
created throughout the simulation by using map structures (=typeMap=
and =contMap=) with the name or alias as key. There is always a
pointer to the root type and another to the root container initialized
in the beginning of the program.  The simulator contains one method
for each type of event described in Appendix \ref{ap.events},
which perform all the validations, besides the processing
itself. Whenever there is an event that defines a type the entity
generated is added to the =typeMap=.  =contMap= and the proper method
of the container object is called.

The PajeContainer class also uses map structures to store all the
entities that are related to it including other containers. Besides
one general structure that lists all of the objects related to the
container (=entities=), there are auxiliar structures for some
specific types, such as states (=stackStates=) and links
(=pendingLinks=). There is some redundancy between =entities= and the
other constructions but, since the objects are pointers, the changes
made in one structure are reflected in the other ones.

Every event that pushes a state will add a state entity to the end of
the =stackStates= stack, while every pop state event will "remove" the
last state in the vector by setting its end time. The simulation keeps
track of the pending communication links and fails if a container is
destroyed, or the simulation ends, before all the links are
completed. The PajeContainer class contains a method for each event
that is associated to a container, adding and removing entities of
these structures listed above.

** Issues of PajeNG

The focus of the Pajé implementation is to allow the user to extend
the Pajé format and adapt the simulator to it. Its support for extra
fields allow the inclusion of different descriptions for the events
and its modularity facilitates the integration of new
classes. Altering or adding simulation behavior can be done by
modifying only the =PajeSimulator= and =PajeContainer=
classes. _*some help to detail more this paragraph? Or should I join
it with the next one?*_

Although complying with its goal of extensibility in terms of
expanding the Pajé format, we identified three main issues in the
current implementation of PajeNG: little flexibility in the
manipulation of data, lack of partial outcomes and ephemeral
results. When the entities are already simulated, a deeper
understanding of the code structure is necessary if one wants to
define another way of handling the results. Also, the user needs to
manage a full set of entities, since there is no flexibility of
discarding data that is not relevant. The second issue relies on the
fact that the =PajeSimulator= instance maintains all of the simulated
objects in memory. If a user wants to see the resulted entities during
the simulation, he would need to get into the =PajeSimulator= code to
make the necessary changes. Technically, since all the results are
stored in memory, it would be simple to add a new functionality, but
it is limited to the manipulation of the whole set of results, not
each entity separately. Last, the results kept in memory during
simulation are discarded at the end, which implies in executing all
the simulation again if a trace file needs to be revisited.

Considering the presented issues, an extensible simulator written in
Java was developed. The intention of this proposal is to make the
simulation core more transparent for the performance analyst providing
the created entities in a way that he can manipulate them without
looking to the rest of the implementation. The program uses the
concept of plugins that attached to every type of event. The simulator
itself addresses the first issue presented, while the creation of new
plugins provide a possible solution to the other two. The details of
this novel approach, developed in our work, are detailed in the next
chapter.

* Aiyra - Java-based simulator
\label{chapter.aiyra}

Aiyra is an extensible simulator written in Java that reads trace
files in the Pajé format and, instead of storing the results in
memory, forwards every created entity to a common place where it can
be manipulated freely. The architecture of the implementation,
characterized in Figure \ref{fig.aiyraArchitecture}, contains three
packages: *parser*, *simulator core* and *plugin*. Every event of a
trace file always goes through all of the packages. First, the trace
file in the input is read by the parser, where a trace event object is
created. This instance contains the type of event in question and the
field values. In the example of Figure \ref{fig.aiyraArchitecture},
the event read is the creation of a container of type *P* with alias
*P1* and parent *0*, which is root. Then, the simulator receives this
object and executes the simulation based on the event type. The
simulation always generates an entity, even if incomplete. In Figure
\ref.{fig.aiyraArchitecture}, a *PajeContainer* is created without an
ending timestamp. Finally, this new entity is sent to the plugin,
which contains specific entry points for every different kind of
entity. 

 _Comment_:
- You should always (when talking about figures) explain the figure. 
  - You did not explain the figure in this case. You should lead the
    reader to check the figure from time to time during reading.
  - This is valid for all figures (before and after this comment)

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Aiyra Architecture}
\centering
\includegraphics[width=\linewidth]{./img/aiyraArchitecture.png}
\label{fig.aiyraArchitecture}
\end{figure}
#+END_LaTeX

The program receives arguments from the user in its execution. The
*filename* option (=-f=) is the only mandatory one, which indicates
what is the trace file to be simulated. There are other two general
options: *comment* (=-m=), a comment about the file; and *plugin*
(=-p=), which indicates which plugin will be used in the
simulation. The details about the already implemented plugins are be
presented in chapter \ref{chapter.plugins} and a step-by-step for the
execution of Aiyra can be found in \ref{ap.aiyraexecute}. The
following subsections detail each one of the packages.

** The Parser: Option Handling and JavaCC

_Comment_:
- Since this "Parser" package also contains option handling, maybe you
  should change its name to something else, like "controller". I say
  controller because the simulator itself is imbricated (embedded) in
  the "Parser".

The parser package is the entry point of the program, thus, it also
handles the arguments passed by the user. For this processing, an
external library \cite{optionhandler} was used. The arguments handling
is centralized in one single class, =OptionsHandler=, to facilitate
the inclusion of new ones. Refer to \ref{ap.optionshandler} for more
details about the library.

A grammar (=PajeGrammar.jj=) describing the elements of the Pajé file
format, presented in section \ref{section.pajeformat}, was created to
be processed by the Java Compiler Compiler. The implementation uses
the =JavaCC= syntax and the complete grammar is in appendix
\ref{ap.grammar}. Each event definition is stored in an array, while
the events are simulated as soon as they are identified.

_Comment_:
- which appendix?
- Perhaps you should say see the appendix only once. It is too
  repetitive as it is now.

The parser package is composed by all of the =JavaCC= files described
in section \ref{section.javacc} and the =OptionsHandler= class. The
generated class =PajeGrammar.java= contains, besides the parsing
component, all the necessary Java code for the program to run, such as
the initialization of the simulator object, where all of the
simulation will be placed. Every time an event is identified, the
simulator instance, which is the entry point of the simulator core
package, is called to simulate that event. Next section describes the
simulator core package.

** Aiyra's Core Simulator

Aiyra's core simulator follows the exact same structure of the
=PajeNG= implementation described in section \ref{section.pajeng},
having the same class hierarchies. Thus, it is equally expandable in
terms of creeating new types of events or entities. However, it does
not support extra fields in the events, which makes it more limited
for extensions in the Pajé Trace file.  As in the =PajeNG=, all of the
events go through the =PajeSimulator= object, which forwards to the
=PajeContainer= if it is an event associated to a container.

_Comments_:
- Why have you opted to leave extra fields out of your implementation?
  - You could say that despite this negative difference on your side,
    it is just a matter of changing everything so the plugins also get
    that kind of information in a generic manner.

Every entity generated is represented by an object with attributes
representing its fields. The class hierarchy of the entities is the
same as the one presented in Figure \ref{fig.entitiesHierarchy}. All
of the types derive from the =PajeType= class, which contains =alias=,
=name=, =depth=, and =parent=, a =PajeType= as well, as attributes. It
also provides the =getNature()= method, to identify which entity this
type describes. The nature is an enumeration and can assume
*ContainerType*, *StateType*, *EventType*, *LinkType* or
*VariableType*. The =PajeVariableType= adds a =PajeColor= to its
attributes, which is an object with the values for red (=r=), green
(=g=), blue(=b=) and alpha(=a=). The =PajeLinkType=, in turn, includes
=startType= and =endType=, which stand for the type of the start and
end containers of the communication. A value is represented by a
=PajeValue= class, with =name=, =alias=, =type= and =color= as
attributes.

A container object (=PajeContainer=) has an =alias=, =name=, =type=
and =parent= (another =PajeContainer=), besides the structures to
store the entities related to it, as described in section
\ref{section.pajeng}. Since the container class is a child of the
=PajeDoubleTimedEntity=, it also has a =startTime= and an
=endTime=. All other entities are associated to a container and a
type, thus, they have a =container= and a =type= fields. The event
entity (=PajeUserEvent=) is the only one that derives from
=PajeSingleTimedEntity=, hence, it has a unique timestamp named
=time=. Also, it has a =value= attribute, which is a =PajeValue=. The
other valued entities, =PajeUserState= and =PajeUserLink=, inherit the
=PajeValue= attribute from the =PajeValuedEntity= class. A
=PajeUserVariable= object also has a =value= attribute but, unlike
events, states and links, it is a double number. The =PajeUserLink=
has a string that defines the =key= and start and end containers
identified by =startContainer= and =endContainer=.

Every trace event simulation has an instrumentation point, which
dispatches the entity objects generated to the plugin package. These
points are either in the =PajeSimulator= or in the =PajeContainer=, as
illustrated in figure \ref{fig.aiyraCore}. In the =PajeSimulator= are
the outputs regarding the definition of types and values and the
creation of containers. Although in this point the containers are not
complete objects, since they don't have ending timestamp or the
related entities, they are forwarded anyway with the alias and type
information. The =PajeContainer= is in charge of dispatching to the
plugin the instances related to it, which involve the states, events,
links and variables. It also may send unfinished objects. When there
is a =PajeDestroyContainerEvent=, the container object is sent again,
now complete with an ending timestamp.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Aiyra's Core Architecture}
\centering
\includegraphics[width=\linewidth]{./img/aiyraCore.png}
\label{fig.aiyraCore}
\end{figure}
#+END_LaTeX

The choice of creating an instrumentation point for each trace event
is due to the intention of covering all of the diffent needs of the
user. One may need the alias of a container before it can process the
entities related to it, for example, which cannot be achieved by
receiving the container only when it is completed. Or else, may be a
situation where the push state events need to be measured, instead of
the pop state events, where the entities are finished. Since we cannot
predict all of the use cases, it is desirable to have a broad
approach. A full list of the plugin entrances and the information
received in each one is presented in the next section.

** Plugin

The plugin package is composed by an abstract class, the =PajePlugin=,
with one method for each instrumentation point. It also contains a
method called *finish* where the user can perform some concluding
actions after the simulation is completed. To create a new plugin, the
user just needs to extend the =PajePlugin= class and override its
functions. It is also possible to extend another plugin, if the
differences are too little and not worth of a new class
implementation.

The entrances of the plugins comprise the definition of types and
values, the creation of containers, and the formation and completion
of new entities. The *newType* entry point is a unique entrance for
when a type of any kind is defined, having the =PajeType= object as
argument. The =getNature()= method can be used to identify the exact
type. The *newValue* method receives every =PajeValue= created.

When a container is created in the simulation, the instance is
forwarded to the *newCreatedContainer* entry point, with the end
timestamp set to =-1=. Whenever a method receives an entity that is
not completed yet, the end timestamp will be =-1=. The
*destroyedContainer* method takes in a complete container that has
just been destroyed. Most of the entities are removed during
simulation, but the destroyed container may have some remaining ones
that could not be excluded, such as variables.

Link entities have three instrumentation points all receiving
=PajeUserLink= objects: *startLink*, where the end time and end
container of the communication link are unknown; *endLink*, when the
instance has the end point of the link but not the start; and
*newCompleteLink*, where the link entity has beginning and
end. Anytime a variable is set or updated, there are three
=PajeUserVariable= entities sent to the plugin: the =first=, which
contains the first value of the variable; the =last=, which is the one
immediately before the variable in question; and the new variable
which is not completed yet (=newVar=). The aditions and subtractions
are sent to the same point (*updateVar*). Since the previous variable
objects are necessary to generate the new value, they are not removed
from memory during simulation. The set, push and pop state events each
have one method receiving a =PajeUserState=: *setState*, *pushState*
and *popState*, the only one with an entity with beginning and end
timestamps. The =PajeUserEvent= objects are sent to the *newEvent*
function.

To validate the concept of the plugins and its entry points, three
plugins were created: =PajeNullPlugin=, =PajeDumpPlugin= and
=PajeInsertDBPlugin=. Their implementation is described in the next
chapter.
  
* Plugins
\label{chapter.plugins} 

In this chapter, two plugins are described: =PajeDumpPlugin= and
=PajeIsertDBPlugin=. The =PajeNullPlugin= is the default one. It does
not make any treatment to the data so the objects are simply
discarded. It is useful to verify the performance of the simulation
itself, whithout the interference of the other segments.

** Paje Dump Plugin

The Dump plugin performs the same action as the =pj_dump= tool, which
dumps to the standard output the entities generated by the
simulator. The implementation consists in inserting a =print= function
in each instrumentation point that receives a complete entity. These
points are: *destroyContainer*, *popState*, *newCompletedLink*, and
*newEvent*. When it is a destroyed container, it is necessary to
iterate over the entities left in the container. The variables printed
in the destruction of the container, since they are not removed during
simulation.

The difference between the =PajeDumpPlugin= and the =pj_dump= tool is
that the first one outputs the information as soon as the entity is
completed. The =pj_dump=, in turn, keeps everything in memory before
dumping it all at once. With this approach, it is possible to solve
the issue regarding the need to wait for the program to end to have
the results.

This plugin can be called with the argument =pjdump= in the =-p=
option and adds a new argument (=-l=) that can group together a
certain number of entities before dumping it. The option receives an
integer as parameter defining the number of lines it should reach
before dumping the entities. This provides a little more flexibility
for the user and may improve the performance, since the printing
function of Java costs time. For it to be possible, a =StringBuilder=
is used as a buffer keeping all of the output until it reaches the
number of lines desired.

** Paje Insert Database Plugin

The =PajeInsertDBPlugin= saves in a relational database all the
results of the simulation. For the implementation, the JDBC driver was
used to make a connection with the MySQL database. The schema used was
specially designed for the Pajé format and will be presented in the
next subsections. This plugin allows the user to save data from
multiple files in the same database.

The plugin can be used by specifying =mysql= as argument for the =-p=
option. It is necessary to have a MySQL connection and a database with
the correct schema. To specify the server of the connection, there is
the option =-s=. It is also possible to inform a username (=-u=), a
password (=-pwd=) and a database name (=-d=). The default for these
options is: =localhost=, =root=, =root= and =paje=, respectively.

To create a relational database for the Pajé format, first, we created
an entity-relationship model that is described in the subsection
below.

*** Entity-Relationship Model

The entity-relationship (ER) model, illustrated in Figure
\ref{fig.ermodel}, contains one entity for each type of Pajé
object. Also, to support multiple files, there is a *file* entity,
which has the =name=, a =comment= and the =date= as attributes, as
well as a =file_id=. The *Type* and *Container* entities have an
identifying relationship with =file=, which means that the file id is
part of their identifier. The relationship is one-to-many, since a
file can have multiple types and containers.

The *Type* entity has =alias=, composing the identifier, =name= and
=depth= as attributes. It also contains a self-referencing one-to-many
relationship to indicate the =parent= type, as a type can have
multiple children. It is associated to a *Value* entity, which
describes the =PajeValue= class, with =alias=, =name=, =type=
(identifying relation) and =color=. Link and variable types have
exclusive attributes that are not common to all types, thus, both are
specializations of *Type*. *LinkType* adds a relationship with itself
to represent a the start and end. This is a many-to-many relationship
because the types can be the start and end to various
communications. The =VariableType= has a color attribute.

The *Container* entity has an identifying one-to-many relashionship
with *Type*, as well as every other entity, since all of them are
classified by a type. Containers have the same attributes as types,
including the =parent= one-to-many relation. All of the entities that
are related to a container, have an identifying one-to-many relation
with *Container* entity. *State* has =startTime= and =endTime=
attributes, where the first is identifier. *Link* has two one-to-many
relationships with *Container*, one for =startContainer= and one for
=endContainer=. A *Variable* entity contains the =Time= attribute, as
well as an =updateTime= in the relation with *Container*. Also, this
relation has a =value= attribute. The *Event* entity has a =time=
field.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{ER Model for the Pajé format}
\centering
\includegraphics[width=\linewidth]{./img/ermodel.png}
\label{fig.ermodel}
\end{figure}
#+END_LaTeX

*** Relational Model

After the creation of the conceptual model, a translation to a logical
model was made. In this conversion, besides applying the universally
known rules presented in chapter \ref{chapter.basic_concepts}, we
considered the usability of the schema, analysing the common
consultations made in the Pajé data. This reflection is a usual part
of the process, where the needs of the client are contemplated.

The entities defined in the ER Model all became tables. For the *Type*
specialization, we used the first option presented in
\ref{subsection.er_relational}: combining everything in a single table
with the following fields: =file_id=, =alias=, =name=, =depth=,
=parent_type_alias=, =start_link_type=, =end_link_type= and
=color=. =File_id=, inherited from the identifying relation with
*File*, and =alias= compose the primary key. The self-referencing
relationships are described as foreign keys in their tables.  The
entities associated to the container all have at least three foreign
keys that are also identifiers: =type_alias=, =container_alias= and
=file_id=. Since the *Link* entity has a unique key, its two foreign
keys from *Container* don't belong to the identifier.

In our ER Model, the value is only associated to the *Type*, thus, if
one wants to know the value of a state, for example, it needs to first
get its type, then, go to *Type* table to retrieve the value. Since it
is desirable to easily get an entity's value, we added a relationship
between the valued entities (*State*, *Link* and *Variable*) with
*Value*. =value_alias= is an identifying foreign key for all, except
*Link*, where the identifier consists only in the =key=, =type= and
=file_id=. With the conceptual model of the *Variable* entity, it is
required to retrieve two rows if one needs to know the beginning and
ending timestamps of one entity. Since this information is very
important, we changed the *Variable* table for the tuples to
explicitly have =startTime= and =endTime=.

*** Implementation

In the =PajeInsertDBPlugin=, the following entry points were used:
*newType*, *newValue*, *newCreatedContainer*, *destroyedContainer*,
*popState*, *newCompleteLink*, *updateVar* and *newEvent*. Types,
values and containers are inserted in the database as soon as they are
created due to the dependency of other entities on these ones. When a
container is destroyed, its =endTime= is updated in the database.

The insertion in the database costs time, hence, the approach of
making an access every time a new entity is created has a very bad
performance. To solve this problem, we used the mechanism of *batches*
provided by JDBC, which sends a block of queries all at once, reducing
the communication overhead. This functionality is optional and can be
included by adding the (=-batch=) option with an integer as
argument. This number will define how many queries it will store
before inserting a batch in the database. This is only appliable to
states, events, links and variables, since types, values and
containers are immediately inserted. An analysis of the performance
for different sizes of batch will be presented in the next chapter.
* Performance Evaluation
\label{chapter.performance}

An evaluation of Aiyra's performance and its plugins was made to ...
Two main tests were executed: a comparison between Aiyra and PajeNG
and an analysis of the impact of different batch sizes in the
=PajeInsertDBPlugin=. Since Aiyra is strongly based in the PajeNG
implementation, it is valid to examine if the modifications and
language transition have brought significant impact on the
simulation. The plugin that inserts the data in a MySQL database is
the only one that brings an extremely different functionality to the
program. As it involves the connection with an external tool, the
analysis of its performance and the study of the most efficient use of
it is very important.

** Methodology

A full factorial experimental design was used to perform the
tests. The different factor and levels for each 
...

_luiza_: OS X Yosemite 10.10.5
Processador: 2.7 GHz Intel Core i7
Memória: 16 GB 1600 MHz DDR3
Gráficos: Intel HD Graphics 4000 1024 MB

_guarani_: 

_orion_: 


Performance Evaluation
   + Overview of what is being evaluated and why 
    - PajeNG. since it is a re implementation
    - inset db plugin, it is the NEW feature. 
    - characterize briefly
   + Experimental Methodology
     - Full factorial
     - Description of each experiment with factors and resulting table
        - null plugin / flex/ reader. hipotesis.
        - batch sizes. why? hipotesis.  
     - characterization of the platforms
   + Results and grafics
   + Possible explanations
   + 

* Conclusion
\label{chapter.conclusion}

- not only the simulator
- plugins are important

*Future Work*
- Plugins in other languages

#+LATEX: \bibliography{References}


\appendix
* JavaCC Tutorial
\label{ap.javacc}

To build a grammar that will be compiled by =JavaCC= you only need to
create one file whith `.jj` extension. The structure of this file is
the following:

#+BEGIN_EXAMPLE
options{

}
#+END_EXAMPLE

A set of optional flags. An example, is the flag =STATIC=, which means
that there is only one parser for the JVM when set to true.

#+BEGIN_EXAMPLE
PARSER_BEGIN(MyGrammar)

public class MyGrammar {

}

PARSER_END(MyGrammar)
#+END_EXAMPLE

In this part, the Java code will be placed and it's the main class of
the program. Notice that the class must have the same name as the
generated parser.

#+BEGIN_EXAMPLE
TOKEN_MGR_DECLS:
{

}
#+END_EXAMPLE

The declarations used by the lexical analyser are placed in the
TOKEN_MGR_DECLS function.

Below these three structures, comes the lexical analysis where the
Token rules and parser actions can be written using a top-down
approach. First, the Tokens are declared, always using the word
"TOKEN" before. To exemplify the creation of a grammar in JavaCC, we
will create a language that consists in the declaration of integer and
char variables and assignments of values to these variables. All the
declarations come first, then the assignments. No verification will be
performed since it is just an example to clarify the JavaCC syntax. To
declare tokens, we use the following notation:

#+BEGIN_EXAMPLE
TOKEN: 
{
  < [NAME] : [EXPRESSION] >  
}
#+END_EXAMPLE

For our example of language we will have the following tokens: 

#+BEGIN_EXAMPLE
/* Integer Literals */
TOKEN : 
{
  < INTEGER: "0" | ["0"- "9"] (["0"-"9")* >
}

/*Variables, assignments and char values*/
TOKEN : 
{
  < VARIABLE: (["a"-"z", "A" - "Z"])+ >
  < ASSIGNMENT: "=" >
  < CHAR: (~["\""] | "\\" (["n","r","\\","\'","\""])) >
} 
/* Types */
TOKEN: 
{
  < INTEGER_TYPE : "int" >
  < CHAR_TYPE: "char" >
}
#+END_EXAMPLE

As we can see in the definitions above, it is not necessary to
explicit the word TOKEN for each one. It is usually separated to be
better organized and easier to understand. Although the token's
agroupation is not relevant, the order in which they are declared
is. When an input matches more than one token specification, the one
declared first will be considered.  There is also another kind of
regular expression production, which is the SKIP. Whatever matches the
regular expression defined in the SKIP scope will not be treated by
the parser.  Example:

#+BEGIN_EXAMPLE
SKIP: 
{
  "\n" 
  \| "\t"

} 
#+END_EXAMPLE

After the token declaration, comes the grammar rules. The rules are
declared as methods, that can have return values or not. The structure
of a method is the following:

#+BEGIN_EXAMPLE
[type] [name] ()
{}
{ 
  /* Rules */
}
#+END_EXAMPLE

The empty braces in the beginning of the method can be filled with
variable declarations in Java. More Java code can be added in the
middle of the rules by using braces. Inside the next braces, it is
possible to assign tokens, regular expressions or even methods to the
variables declared earlier. To refer to the tokens, we use its name
between angular brackets. Example:

#+BEGIN_EXAMPLE
void parser()
{ int number; }
{
  number = <INTEGER>
}
#+END_EXAMPLE

The first method defined will be the entrance to the parser and it can
contain methods inside that will be expanded later in the rules. The
entrance for the language we are using as an example would be as
follows:

#+BEGIN_EXAMPLE
void start()
{}
{
  declarations() assignments() <EOF>
}
#+END_EXAMPLE

EOF is a default token. It is important to guarantee that the file
will be parsed until the end. By the definition of our first method,
we assure that the declarations will obligatorily be in the beginning,
and the assignments at the end. Next, we expand the two methods to
address all the possibilities:

#+BEGIN_EXAMPLE
void declarations()
{}
{
  ((<INTEGER_TYPE> | <CHAR_TYPE>) <VARIABLE>)*
}

void assignments()
{}
{
  (<VARIABLE> <ASSIGNMENT> (<CHAR> | <INTEGER>))*
}

#+END_EXAMPLE

The multiplicity can be defined with the standard characters "*", "?",
"+", just as in the lexer. This example is just one possible approach
to define these rules. For example, you can use another non-terminal
to describe a value that will be assigned to a variable. In this case,
the assignments() rule would be expanded as follows:

#+BEGIN_EXAMPLE
void assignments()
{}
{
  (<VARIABLE> <ASSIGNMENT> assignable() )*
}

void assignable():
{}
{
  <CHAR> | <INTEGER> 
}
#+END_EXAMPLE

*** Usage with Java

In order to call the parser in a Java program, an object of the
MyGrammar class needs to be instantiated:

#+BEGIN_EXAMPLE
MyGrammar parser = new MyGrammar(input);
#+END_EXAMPLE

Then, once there is an instance of the parser, it is possible to call
the first method of the parser:

#+BEGIN_EXAMPLE
parser.start();
#+END_EXAMPLE

This code has a Java syntax and is placed in the main class presented
previously. Between the declarations of PARSER_BEGIN and PARSER_END,
any Java code can be placed to manipulate the results of the parsing.

#+BEGIN_EXAMPLE
PARSER_BEGIN(MyGrammar)
/* Imports */
public class MyGrammar {
    public static void main(String args []){
        /* Code to read the input */

        MyGrammar parser = new MyGrammar(input);
        parser.start();

       /* Java code to manipulate the parser results */
  
  }

}

PARSER_END(MyGrammar)
#+END_EXAMPLE
* Paje File Format Specification
\label{ap.pajeformat}

The Pajé Trace File Format has two parts: event definition and events.
The format of the event definition part has the following format:

- Every line of the event definition part of the Pajé format starts
  with the character "%".
- An event definition starts with "%EventDef" plus the =name= of the
  event followed by a =unique number= to identify it.
- An event definition ends with "%EndEventDef".
- Between the "%EventDef" and "%EndEventDef" lines there is a list of
  fields, one per line, with =name= and =type=.
- It is possible to have two events with the same name but different
  identification numbers. This is useful to specify different sets of
  fields for the same type of event.

The types of fields can be: 

=date=: a double precision floating-point number, which usually means
the seconds since the program started;

=int=: integer number;

=double=: floating-point number;

=hex=: address in hexadecimal;

=string=: string of characters;

 =color=: a sequence of three to four floating-point numbers between 0
and 1 inside double quotes. The values mean red, green, blue and
alpha(optional).

An example of event definition: 

#+BEGIN_EXAMPLE
%EventDef PajeNewEvent 17
%       Time date
%       Container string
%       Type string
%       Value double
%EndEventDef
#+END_EXAMPLE

*** Events
\label{ap.events} 

_Comments_: great, all this to the appendix. Keep here a very small
fraction corresponding to an overview. Reference the appendix for
details.

After the event definition, the events themselves are described, one
in each line. Every event starts with the number that identifies it,
which was defined previously. For the example above, every line that
contains a =PajeNewEvent= event will start with the number 17. The
fields are separated by space or tab and must appear in the same order
as it was declared in the definition. In the example below, there is a
PajeNewEvent event with timestamp =3.14532=, of type =S=, in the
container =p1=, and with value =M=:

#+BEGIN_EXAMPLE
17 3.14532 p1 S M
#+END_EXAMPLE

Fields of type =string= don't need to be double quoted unless they are
empty or have a space or tab character. Before the entities can be
created, a hierarchy of types and containers must be defined and
containers need to be intantiated, since every entity belongs to a
container.

**** Types
Type doesn't have a timestamp and can be declared at anytime in a
trace file, as long as it is not used before its definition. It is
more common to have all the types defined in the beginning. There are
6 different type definitions, one for each sort of entity and one for
value objects:

=PajeDefineContainerType=: Must have the fields _Name_ and _Type_, and
can have an optional field _Alias_. Defines a new container type
called _Name_, contained in a previously defined container of type
_Type_.

=PajeDefineStateType=: Must have the fields _Name_ and _Type_, and can
have an optional field _Alias_. Defines a new state type called
_Name_, contained in a previously defined container of type _Type_.

=PajeDefineEventType=: Must have the fields _Name_ and _Type_, and can
have an optional field _Alias_. Defines a new event type called
_Name_, contained in a previously defined container of type _Type_.

=PajeDefineVariableType=: Must have the fields _Name_, _Type_ and
_Color_, and can have an optional field _Alias_. Defines a new
variable type called _Name_, contained in a previously defined
container of type _Type_, with the color _Color_. Notice that the
color is associated to the type, and not to the object. Therefore,
every variable of determined type will have the same color.

=PajeDefineLinkType=: Must have the fields _Name_, _Type_,
_StartContainerType_ and _EndContainerType_, and can have an optional
field _Alias_. Defines a new link type called _Name_, contained in a
previously defined container of type _Type_, that connects the
previously defined container type _StartContainerType_ to the
previously defined _EndContainerType_. Also, the container type given
in _Type_ must be an ancestral of both start and end container types.

=PajeDefineEntityValue=: Must have the fields _Name_, _Type_ and
_Color_, and can have an optional field _Alias_. This is an optional
event that defines the possible values of an entity type, which can be
a State, Link or Event. Defines a new value called _Name_ for the
previously defined type _Type_ with color _Color_. Notice that this
value is an entity, differently from the one indentifying a variable,
which is a double value.

**** Containers
Intances of containers can be created and destroyed during the trace
file. A container cannot be referenced after it was destroyed. The
events associated to the containers are timestamped.

=PajeCreateContainer=: Must have the fields _Time_, _Name_, _Type_ and
_Container_, and can have an optional field _Alias_. Creates, at
timestamp _Time_, a container instance called _Name_, of the container
type _Type_ and that is a child of the previously created container
_Container_.

=PajeDestroyContainer=: Must have the fields _Time_, _Name_ and
_Type_. Destroys, at timestamp _Time_, a container instance called
_Name_, of the container type _Type_.

**** States
The state events change the values of a determined container's state,
by setting, pushing, popping and reseting.

=PajeSetState=: Must have the fields _Time_, _Type_, _Container_ and
_Value_. Changes, at timestamp _Time_, to the value _Value_, the state
type _Type_, of the container identified by _Container_.

=PajePushState=: Must have the fields _Time_, _Type_, _Container_ and
_Value_. Pushes, at timestamp _Time_, the value _Value_ of the state
type _Type_, in the container identified by _Container_. The push event
saves the existing value of the same state.

=PajePopState=: Must have the fields _Time_, _Type_ and
_Container_. Pops, at timestamp _Time_, the last state of type _Type_
in the container identified by _Container_.

=PajeResetState=: Must have the fields _Time_, _Type_ and
_Container_. Clears, at timestamp _Time_, the state of type _Type_ in
the container identified by _Container_. If the stack is empty, the
event does nothing.

**** Events
An event is something that is relevant enough to be acknowledged and
has a unique timestamp.

=PajeNewEvent=: Must have the fields _Time_, _Type_, _Container_ and
_Value_. Instantiates, at timestamp _Time_, a remarkable event of type
_Type_, in the container _Container_, with value _Value_.

**** Variables
Variables are set at a specific timestamp and can have its value
changed throughout the simulation. The value of a variable is a double
precision floating-point number, which is different from the values of
the other entities. A variable must be set before changes to its value
can be made.

=PajeSetVariable=: Must have the fields _Time_, _Type_, _Container_
and _Value_. Instantiates, at timestamp _Time_, a variable of type
_Type_, in the container _Container_, with value _Value_.

=PajeAddVariable=: Must have the fields _Time_, _Type_, _Container_
and _Value_. Adds, at timestamp _Time_, a value _Value_, to an existing
variable of type _Type_, in the container _Container_.

=PajeAddVariable=: Must have the fields _Time_, _Type_, _Container_
and _Value_. Subtracts, at timestamp _Time_, a value _Value_, of an
existing variable of type _Type_, in the container _Container_.

**** Links
A link can start at a container and end in another one. Every
completed link is identified by a unique key.

=PajeStartLink=: Must have the fields _Time_, _Type_, _Container_,
_StartContainer_, _Value_ and _Key_. Indicates, at timestamp _Time_,
the beginning of a link of type _Type_, in container _Container_,
starting from _StartContainer_, with value _Value_, and identified by
key _Key_.

=PajeEndLink=: Must have the fields _Time_, _Type_, _Container_,
_EndContainer_, _Value_ and _Key_. Indicates, at timestamp _Time_, the
end of a link of type _Type_, in container _Container_, ending in
_EndContainer_, with value _Value_, and identified by key _Key_.

* PajeNG structures
\label{ap.pajeng}

*Simulator*

=typeMap=: a map containing all the types that have been defined in
the simulation, with name or alias as key;

=contMap=: a map of the created containers also identified by the name
or alias.

*Container*

=stackStates=: a map identified by the type and with a vector of state
entities as the value. Every event of type =PajePushState= will add a
state entity to the end of the stack, while every =PajePopState= will
"remove" the last state in the vector by setting its end time;

=pendingLinks=: a map of pending links stores the communications that
were opened but have not been closed yet. The link key is the
identification, and the simulation fails if a container is destroyed,
or the simulation ends, before all the links are completed;

=linksUsedKeys=: a map listing all the keys for links that were
already used in this container.

=entities=: This map lists all the entities that belong to the
container, even if they were already listed in the other
structures. What identifies an entity is its type and container,
hence, the PajeType is the key of this map and a vector of entities is
the value. Here, we notice the importance of having the single parent
type class PajeType, and a unique parent entity class, PajeEntity, to
group together different types of objects. Since the objects are
pointers, the changes made in one structure are reflected in the other
ones. All of the variable and event objects are stored in this general
list of entities.

* Processing Command Line Arguments 
\label{ap.optionshandler}

Since handling command line arguments is not very straightforward in
Java, an external library \cite{optionhandler} was used. The command
line arguments are used for the user to pass information to the
simulator, such as the name of the file to be processed, or a comment
about the trace.

All of the arguments processing is done in one class:
=OptionsHandler=. The options that are needed in the simulation core
are stored in this single class. These are: 

*filename*: a string that receives the name of the trace file to be
read;

*comment*: a string that stores an optional comment about the file;

The centralization of the options has the objective of facilitating
the extensibility of the program. The arguments regarding a specific
plugin are sent directly to its proper object.

The constructor of this class receives the list of arguments that was
passed in the execution of the program and creates an object =opt= of
type =Options= with the arguments as parameter. 

#+BEGIN_EXAMPLE
import ml.options.Options;

public class OptionsHandler {

  public Options opt;

  public OptionsHandler(String args[]) {
	  opt = new Options(args);	
  }
}

Options opt
#+END_EXAMPLE

The Options type is the core of the library used, and all of the argument's
processing will be done in the =opt= instance. It is also in the
constructor that we set all of the possible options that can be used
by the user. To define a new one, we use the following line of
code:

#+BEGIN_EXAMPLE
opt.getSet().addOption("<alias>", Options.Separator.<SEPARATOR>, Options.Multiplicity.<MULTIPLICITY>);
#+END_EXAMPLE

=<alias>=: the alias that will be used to identify the option;

=<SEPARATOR>=: used for options that have a value. Can be *COLON*,
*EQUALS*, *BLANK* or *NONE*;

=<MULTIPLICITY>=: the multiplicity defines if the value is required or
optional, or if it can appear more than once. The possible values are:
*ONCE*, *ONCE_OR_MORE*, *ZERO_OR_ONE*, *ZERO_OR_MORE*.


The default for the prefix is a dash and is the one chosen for the
program. The constructor of Aiyra's OptionsHandler class has the
following definitions:

#+BEGIN_EXAMPLE
opt.getSet().addOption("f", Options.Separator.BLANK, Options.Multiplicity.ONCE);
opt.getSet().addOption("m", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);
opt.getSet().addOption("p", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);		
#+END_EXAMPLE

=-f=: required field that indicates the file to be parsed;

=-m=: an optional comment about the trace;

=-p=: the plugin to be used by the simulator.

To check if the user has passed the arguments properly, the Options
class provides a simple method thet returns a boolean:

#+BEGIN_EXAMPLE
opt.check
#+END_EXAMPLE

In the OptionsHandler class, this verification is done in the
=checkOptionsHelper= method, which prints a helper text to the user in
case the check fails.

#+BEGIN_EXAMPLE
public void checkOptionsHelper() {
	// true=ignoreUnmatched false=requireLast
	if (!this.opt.check(true, false)) {
		System.out.println("Your input is incorrect");
		System.out.println("Please use the following notation:");
		System.out.println("-f <path-to-filename>");
		System.out.println("-m <comment> (optional)");
		System.out.println("-p <plugin> (optional, default: null) ");
			
		System.exit(1);
	}
}
#+END_EXAMPLE

This validation must be done before the program continues, thus, this
method is already called in the constructor:

#+BEGIN_EXAMPLE
 public OptionsHandler(String args[]) {
	  opt = new Options(args);

      opt.getSet().addOption("f", Options.Separator.BLANK, Options.Multiplicity.ONCE);
      opt.getSet().addOption("m", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);
      opt.getSet().addOption("p", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);

      checkOptionsHelper();	
  }
#+END_EXAMPLE 

* Paje File Format Parser for JavaCC
\label{ap.grammar}
* How to execute aiyra
\label{ap.aiyraexecute}
