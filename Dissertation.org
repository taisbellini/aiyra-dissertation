#+TITLE: 
#+AUTHOR: Tais Bellini

#+STARTUP: overview indent
#+LANGUAGE: en
#+OPTIONS: H:3 creator:nil timestamp:nil skip:nil toc:nil num:t ^:nil ~:~
#+OPTIONS: author:nil title:nil date:nil
#+TAGS: noexport(n) deprecated(d) ignore(i)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+LATEX_CLASS: iiufrgs
#+LATEX_CLASS_OPTIONS: [times,cic,tc]
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{subfigure}
#+LATEX_HEADER: \usepackage{tabulary}
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{algorithmic}
#+LATEX_HEADER: \newcommand{\prettysmall}{\fontsize{6.5}{6.5}\selectfont}
#+LATEX_HEADER: \newcommand{\prettysmallbis}{\fontsize{7}{7}\selectfont}
#+LATEX_HEADER: \newcommand{\mtilde}{~}

#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{palatino}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{cleveref}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage[normalem]{ulem}
#+LATEX_HEADER: \usepackage{xspace}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \graphicspath{{img/}{img/final/}}
#+LATEX_HEADER: \hypersetup{hidelinks = true}

#+LATEX_HEADER: \newcommand{\review}[1]{\textcolor[rgb]{1,0,0}{[Lucas: #1]}}
#+LATEX_HEADER: \newcommand{\lucas}[1]{\textcolor[rgb]{0.2,0.2,0.7}{[Lucas: #1]}}

#+BEGIN_LaTeX
\title{TCC da Tais}
\author{Loureiro Bellini}{Tais}
\advisor[Prof.~Dr.]{Mello Schnorr}{Lucas}
\date{Junho}{2016}
\location{Porto Alegre}{RS}

% \renewcommand{\nominataReit}{Prof\textsuperscript{a}.~Wrana Maria Panizzi}
% \renewcommand{\nominataReitname}{Reitora}
% \renewcommand{\nominataPRE}{Prof.~Jos{\'e} Carlos Ferraz Hennemann}
% \renewcommand{\nominataPREname}{Pr{\'o}-Reitor de Ensino}
% \renewcommand{\nominataPRAPG}{Prof\textsuperscript{a}.~Joc{\'e}lia Grazia}
% \renewcommand{\nominataPRAPGname}{Pr{\'o}-Reitora Adjunta de P{\'o}s-Gradua{\c{c}}{\~a}o}
% \renewcommand{\nominataDir}{Prof.~Philippe Olivier Alexandre Navaux}
% \renewcommand{\nominataDirname}{Diretor do Instituto de Inform{\'a}tica}
% \renewcommand{\nominataCoord}{Prof.~Carlos Alberto Heuser}
% \renewcommand{\nominataCoordname}{Coordenador do PPGC}
% \renewcommand{\nominataBibchefe}{Beatriz Regina Bastos Haro}
% \renewcommand{\nominataBibchefename}{Bibliotec{\'a}ria-chefe do Instituto de Inform{\'a}tica}
% \renewcommand{\nominataChefeINA}{Prof.~Jos{\'e} Valdeni de Lima}
% \renewcommand{\nominataChefeINAname}{Chefe do \deptINA}
% \renewcommand{\nominataChefeINT}{Prof.~Leila Ribeiro}
% \renewcommand{\nominataChefeINTname}{Chefe do \deptINT}


% \keyword{formatação eletrônica de documentos}
% \keyword{\LaTeX}
% \keyword{ABNT}
% \keyword{UFRGS}



\maketitle



#+END_LaTeX

                                                      
# #+BEGIN_LaTeX
# \begin{abstract}
# #+END_LaTeX


# #+BEGIN_LaTeX
# \end{abstract}
# #+END_LaTeX


* Configuring Emacs to correctly export to PDF			   :noexport:

Org mode is configured by default to export only the base classes.

See for details:
+ http://orgmode.org/worg/org-tutorials/org-latex-export.html

Execute the following code (with C-c C-c) prior to export this file to PDF.

#+BEGIN_SRC emacs-lisp :results silent :exports none
(add-to-list 'org-latex-classes
             '("iiufrgs"
               "\\documentclass{iiufrgs}"
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC
* 2016-03-18 First entry (proper emacs configuration file)   :noexport:Lucas:

I recommend you use Arnaud's emacs configuration file, available here:
+ http://mescal.imag.fr/membres/arnaud.legrand/misc/init.php

Download the file =init.org=:

#+begin_src sh :results output :session :exports both
wget http://mescal.imag.fr/membres/arnaud.legrand/misc/init.org
#+end_src

#+RESULTS:

* 2016-04-29 How to compile with _bibtex_ entries              :Lucas:noexport:

Do as follows:

1. Export as usual to latex
2. Then, type in the terminal
   #+begin_src sh :results output :session :exports both
   pdflatex Dissertation.tex
   bibtex Dissertation
   pdflatex Dissertation.tex
   pdflatex Dissertation.tex
   #+end_src

* Introduction
Observation of program behavior is particularly important in High
Performance Computing since it enables an accurate performance
analysis \cite{XXX}. A very common method of evaluation is registering
program events in trace files that work as a log, so, whenever a
relevant event happens, it will be logged in the trace file with the
proper information \cite{XXX}. Then, these traces are replayed in
simulation combining information that is spread across multiple events
deriving new and richer entities \cite{XXX}. This event processing is
usually done once and discarded, which can be very inconvenient
considering that some trace files are very large. Therefore, it would
be interesting to save these entities for further analysis.

In this context of performance analysis, a common tool used is the
Pajé Trace Simulator \cite{kergommeaux2000paje}, an open source
project that reads trace files in a specific format, the Pajé Trace
File Format \cite{pajetracefile}, and processes five types of
entities: Containers, States, Events, Variables and Links. These
concepts represent basic structures of computer programs executed in
parallel or distributed systems, such as processes, threads, network
links, hardware counters and so on. As a base for the implementation
of this proposal, the new generation of Pajé, PajeNG \cite{XXX}, was
used. Details of PajeNG, the types of entities and the Pajé File
Format will be presented in Chapter \ref{chapter.paje}. Although it
has a visualization functionality, we will focus on the simulation
part of the Pajé implementation in this project. The most commonly
used tool of PajeNG is the Pajé Dump (=pj_dump=) \cite{XXX}, that
dumps to the standard output all information regarding entities
created throughout the simulation.

There are at least three problems with the current implementation of
Pajé: little extensibility, lack of partial outcomes and impermanent
results. The original Pajé and, consequently, its next generation were
idealized and built in an extensible way, that could be easily
expanded based on the user's needs. Although the implementation is
very modular, it is necessary to write a full component for Pajé,
which is a complex thing because it implies in understanding the
internal objects, class hierarchy, protocol, and so on. Until now,
very few people have actually extended this tool. Throughout the
simulation, the Pajé tool creates entities according to the events
listed in the trace file, saving each one of them in memory to dump
everything at once in the end. Since some trace files can be very
large (over 1 Gigabyte), it may take a while for the results to be
printed out. Besides not being able to have a partial view of already
simulated entities, the user won't have records of the results between
executions for different files unless he specifies a destination for
it himself. To address these issues, an extensible trace files
simulator, Aiyra, was developed in Java.

The objective of this proposal is to allow the performance analyst to
change the simulator behavior when a new entity is detected. Thus, the
partial results can be immediately presented to the user, or saved in
a database, or even discarded if not relevant. This extensibility is
implemented through the concept of plugins that are attached to the
simulator in specific and important points where the trace events are
combined. This main objective solves the lack of extensibility
problem. Once the simulator allows the immediate manipulation of the 
entities, the other two issues can be easily addressed with
extensions. Hence, the secondary objectives of the project are the 
creation of plugins to dump partial data that has just been simulated 
and to make the results permanent.

For the validation of the extensible trace files simulator, two
plugins were implemented: Paje Dump Plugin and Paje Insert Database
Plugin. The first one plays the same roll as the original Paje Dump
tool in the Paje new generation, with the difference that the entities
are dumped at the moment they are completed. The second one inserts
all the data in a relational database. A specific schema for the Pajé
Format was designed and will be presented in Chapter
\ref{chapter.plugins}.  A performance analysis was developed to
compare Aiyra against the previous one. It is worth highlighting that
the new simulator had better performance results with bigger files
(over 120 Megabytes), that being possibly attributed to the fact that
it discards from memory entities that will no longer be
used. Additionally, the Pajé Insert Database plugin was evaluated
comparing its different possibilities of usage. In this investigation,
we varied the frequency of the insertions in the database by grouping
queries in memory until it had a specific size to insert. The
objective of this test was to understand the impact of an access to a
database in the performance of the program. Likewise, the usage of the
memory was also examined to determine the best balance between
excution time and memory management. As we will see in Chapter 6, the
memory usage had more impact in the performance than the accesses to
the database themselves, probably due to the Garbage Collector
mechanism used by Java.

This document is organized as follows. Chapter
\ref{chapter.basic_concepts} provides the basic concepts of the
technologies used throughout the project. Chapter \ref{chapter.paje}
gives an overview of the existing simulator for the Pajé format and
the problems with this current implementation. Chapter
\ref{chapter.aiyra} describes the details of the extensible simulator
developed in Java and Chapter \ref{chapter.plugins} characterize the
plugins developed. Chapter \ref{chapter.performance} presents a
performance analysis of the Pajé Insert Database Plugin and a
comparison between Aiyra and PajeNG. The conclusion and final
considerations are expressed in Chapter \ref{chapter.conclusion}.


* Basic Concepts
\label{chapter.basic_concepts}

In this Chapter, the basic concept of the technologies used to develop
this project will be presented to guarantee a full understanting of
all the process.

_Comment_: a more direct way of introducing the chapter follows. "This
chapter presents the basic concepts of technologies adopted to develop
this project. They contribute to the understanding of our work."

_Comment_: state very briefly (one phrase) what you are going to write
about in the chapter. Example: "Two topics are covered: the Java
Compiler Compiler (JavaCC) and the a general overview about
experimental design in the scope of the R language."

** The Java Compiler Compiler (JavaCC) tool

The first part of Aiyra simulator consists in reading a trace file,
that is in a specific standard, and parsing it to define how each line
of the entry will be simulated. 

_Comment_: It is very strange to me find things about Aiyra here. You
haven't presented it yet. Stick to the basics: there is no need to
justify why you are talking about JavaCC. You could start directly
with something like this: "Java Compiler Compiler (JavaCC) is a
lexical and parser generator..."

For that, a lexical and parser
generator, called Java Compiler Compiler (JavaCC), was used. 

_Comment_: Be more direct. I recommend the reading of the book "The Elements of Style".

JavaCC
behaves similarly to Flex and Bison

_Comment_: What are Flex and Bison?

, receiving a set of regular
expressions describing the tokens of the language and a grammar
defined using these tokens. The output of the generator is a lexical
analyser, that separates the input file into tokens, and a parser,
which performs a syntax analysis. What differentiates JavaCC from
other parser generators that exist for the Java language is that it
creates files written in pure Java,

_Comment_: it generates source code in Java.

 which facilitates the
understanding and eliminates the need of having dependencies in the
code. JavaCC has also shown itself to have a much better performance
than other tools such as ANTLR (Another Tool For Language
Recognition), that requires a runtime library.

_Comment_: You need to cite someone that shows that JavaCC is faster
than ANTLR.

JavaCC can be downloaded, unziped and added to the PATH. It also has a
plugin for Eclipse. Once installed, JavaCC will process your grammar
defined in a file with extension ".jj" using the command
#+BEGIN_EXAMPLE
javacc
#+END_EXAMPLE

_Comment_: You can be simpler by using =javacc= instead of the Example env.
 
As an example, I will use =MyGrammar.jj=. The result of the processing
are seven files:

=MyGrammar.java=: The parser;

=MyGrammarTokenManager.java=: The lexical analyser, that manages the tokens;

=MyGrammarConstants.java= : Some useful constants. 

_Comments_: Usually we avoid the use of singular first person
(i.e. I). Use plural first person (i.e. "We"). Perhaps a figure here
would be nice.

The other four files generated: =Token.java=, =TokenMgrError.java=,
=SimpleCharStream.java= and =ParseException.java= are boilerplate
files that can be reused within parsers and are not affected by the
grammar itself.  Once having ".java" files, it is possible to compile
them using "javac" as usual.

_Comment_: "Once the corresponding Java source code for the scanner and
parser are generated, compile them as usual with =javac=."

_Comment_: Before going to the subsections below, state what you are
going to talk about.

*** Structure and syntax

The whole grammar will be in the =MyGrammar.jj= file and it is the
only file that needs to be modified. There, the tokens used will be
defined, the parser rules specified, and it is possible to even add
Java code that has to be executed during the parsing. The structure of
this file is the following:

#+BEGIN_EXAMPLE
options{

}
#+END_EXAMPLE

A set of optional flags. An example, is the flag =STATIC=, which means
that there is only one parser for the JVM when set to true.

#+BEGIN_EXAMPLE
PARSER_BEGIN(MyGrammar)

public class MyGrammar {

}

PARSER_END(MyGrammar)

#+END_EXAMPLE

In this part, the Java code will be placed and it's the main class of
the program. Notice that the class must have the same name as the
generated parser.

#+BEGIN_EXAMPLE
TOKEN_MGR_DECLS:
{

}
#+END_EXAMPLE

The declarations used by the lexical analyser are placed in the
TOKEN_MGR_DECLS function.

Below these three structures, comes the lexical analysis where the
Token rules and parser actions can be written using a top-down
approach. First, the Tokens are declared, always using the word
"TOKEN" before. To exemplify the creation of a grammar in JavaCC, we
will create a language that consists in the declaration of integer and
char variables and assignments of values to these variables. All the
declarations come first, then the assignments. No verification will be
performed since it is just an example to clarify the JavaCC syntax. To
declare tokens, we use the following notation:

#+BEGIN_EXAMPLE
TOKEN: 
{
  < [NAME] : [EXPRESSION] >  
}

#+END_EXAMPLE

For our example of language we will have the following tokens: 


#+BEGIN_EXAMPLE
/* Integer Literals */
TOKEN : 
{
  < INTEGER: "0" | ["0"- "9"] (["0"-"9")* >
}

/*Variables, assignments and char values*/
TOKEN : 
{
  < VARIABLE: (["a"-"z", "A" - "Z"])+ >
  < ASSIGNMENT: "=" >
  < CHAR: (~["\""] | "\\" (["n","r","\\","\'","\""])) >
} 
/* Types */
TOKEN: 
{
  < INTEGER_TYPE : "int" >
  < CHAR_TYPE: "char" >
}

#+END_EXAMPLE

As we can see in the definitions above, it is not necessary to
explicit the word TOKEN for each one. It is usually separated to be
better organized and easier to understand. Although the token's
agroupation is not relevant, the order in which they are declared
is. When an input matches more than one token specification, the one
declared first will be considered.  There is also another kind of
regular expression production, which is the SKIP. Whatever matches the
regular expression defined in the SKIP scope will not be treated by
the parser.  Example:

#+BEGIN_EXAMPLE
SKIP: 
{
  "\n" 
  \| "\t"

} 
#+END_EXAMPLE

After the token declaration, comes the grammar rules. The rules are
declared as methods, that can have return values or not. The structure
of a method is the following:

#+BEGIN_EXAMPLE
[type] [name] ()
{}
{ 
  /* Rules */
}
#+END_EXAMPLE

The empty braces in the beginning of the method can be filled with
variable declarations in Java. More Java code can be added in the
middle of the rules by using braces. Inside the next braces, it is
possible to assign tokens, regular expressions or even methods to the
variables declared earlier. To refer to the tokens, we use its name
between angular brackets. Example:

#+BEGIN_EXAMPLE
void parser()
{ int number; }
{
  number = <INTEGER>
}
#+END_EXAMPLE

The first method defined will be the entrance to the parser and it can
contain methods inside that will be expanded later in the rules. The
entrance for the language we are using as an example would be as
follows:

#+BEGIN_EXAMPLE
void start()
{}
{
  declarations() assignments() <EOF>
}
#+END_EXAMPLE

EOF is a default token. It is important to guarantee that the file
will be parsed until the end. By the definition of our first method,
we assure that the declarations will obligatorily be in the beginning,
and the assignments at the end. Next, we expand the two methods to
address all the possibilities:

#+BEGIN_EXAMPLE
void declarations()
{}
{
  ((<INTEGER_TYPE> | <CHAR_TYPE>) <VARIABLE>)*
}

void assignments()
{}
{
  (<VARIABLE> <ASSIGNMENT> (<CHAR> | <INTEGER>))*
}

#+END_EXAMPLE

The multiplicity can be defined with the standard characters "*", "?",
"+", just as in the lexer. This example is just one possible approach
to define these rules. For example, you can use another non-terminal
to describe a value that will be assigned to a variable. In this case,
the assignments() rule would be expanded as follows:

#+BEGIN_EXAMPLE
void assignments()
{}
{
  (<VARIABLE> <ASSIGNMENT> assignable() )*
}

void assignable():
{}
{
  <CHAR> | <INTEGER> 
}
#+END_EXAMPLE

*** Usage with Java

In order to call the parser in a Java program, an object of the
MyGrammar class needs to be instantiated:

#+BEGIN_EXAMPLE
MyGrammar parser = new MyGrammar(input);
#+END_EXAMPLE

Then, once there is an instance of the parser, it is possible to call
the first method of the parser:

#+BEGIN_EXAMPLE
parser.start();
#+END_EXAMPLE

This code has a Java syntax and is placed in the main class presented
previously. Between the declarations of PARSER_BEGIN and PARSER_END,
any Java code can be placed to manipulate the results of the parsing.

#+BEGIN_EXAMPLE
PARSER_BEGIN(MyGrammar)
/* Imports */
public class MyGrammar {
    public static void main(String args []){
        /* Code to read the input */

        MyGrammar parser = new MyGrammar(input);
        parser.start();

       /* Java code to manipulate the parser results */
	
  }

}

PARSER_END(MyGrammar)
#+END_EXAMPLE

** Experimental Design and the R Language

For the performance evaluation, we used the technique of experimental
design, which is a form of performance analysis that aims to define a
minimum number of experiments that will collect the maximum
information necessary. It also targets random variations that could
affect the results, guaranteeing that the number of tests executed and
the error margin calculated will be suficient to avoid misleading
conclusions.

*** Terminology
The terminology used in experimental design is the following: 

=Response Variable=: The outcome of an experiment;

=Factors=: All the variables that could have several different values
affecting the response variable;

=Levels=: The possible values that a factor can assume;

=Primary Factors=: The factors that need to be quantified;

=Secondary Factors=: The factors whose impacts in the performance are
not relevant for the analysis;

=Replication=: The repetition of all or some experiments;

=Design=: The specification of total number of experiments, based on
factor level combination and number of replications for each
experiment.

=Experimental Unit=: The entity used for the experiment, for example,
a computer;

=Interaction=: When the levels of a fator affect the results of other
factor.

*** Full Factorial Design

There are several types of experimental design modeling. In this
project, we used a full factorial design, which consists in analysing
every possible combination at all levels of all factors. With this
type of design, it is possible to evaluate factors that have different
numbers of levels. The advantage of this model is that every possible
combination will be analysed, generating richer results. However,
depending on the number of factors, levels and replications, it may
generate a very large total number of experiments, which can cost a
lot of time. Therefore, when using this technique, it is important to
weight the relevance of each factor and level to generate an
appropriate and accurate design. To calculate the total size of the
sample you multiply the numbers of levels of the factors and the
number of replications. For example, a design with a three-level
factor and a two-level factor with 20 replications would have 120
experiments (3*2*20).

*** R language
R is a language for statistical computing and graphics generation. It
can be very easily extended, by creating and using packages. To create
the design for the experiments of this work, the =Doe.base= package
was used.

DoE.base is a package to generate full factorial experimental
designs. It contains the class _design_ with several accessor
functions to create different types of design. One particular
important function is the _fac.design_, which creates full factorial
designs with arbitrary numbers of levels. The function receives
several arguments, including number of factors, levels and
replication. The usage of the function is the following:

#+begin_src R :results output silent :session :exports none
  require(DoE.base);
  fac.design (
           nfactors=NULL,
           replications=1,
           repeat.only=FALSE,
           blocks=1,
           randomize=TRUE,
           seed=NULL,
           nlevels=NULL,
           factor.names= NULL )
#+end_src

=nfactors=: The number of factors;

=replications=: The number of replications;

=repeat.only=: If true, replications of each run are grouped together;

=blocks=: Number of blocks in which the experiment wil lbe
subdivided. Must be a prime;

=randomize=: If true, the design is randomized;

=seed=: seed For the randomization (optional);

=nlevels=: A vector with the number of levels for each factor;

=factor.names=: A list of vectors with factor levels. 

* Pajé Visualization Tool - PajeNG 
\label{chapter.paje}

The Pajé Visualization Tool is a tool to display the execution of
parallel and distributed programs. It reads information from trace
files that describe the important events in the execution of a
parallel program and replays them in simulation. It is developed to
simulate trace files in the Pajé Trace File Format, thus, it is
important to understand how the Pajé trace files are composed. Section
\ref{section.pajeformat} describes this format and all the types of
entities. The next section describes the PajeNG implementation
focusing on the =libpaje= module, which is where the core simulation
is performed. Since the new generation follows the exact same
structure as the original Pajé, it will be the only one to be
described.
 

** Pajé Trace File Format
\label{section.pajeformat}

The Pajé Trace File Format is a textual and generic format that
describes the behavior of paralell and distributed programs. This
format contains three sections: event definition, type hierarchy
declaration and timestamped events. The Pajé format describes five
types of entities: Containers, States, Events, Variables and
Links. Each entity is always associated to a container, even the
containers themselves. Below, a succint definition of each type of
entity:

*Container*: A container can be any hardware or software entity, such
as a processor, a thread, a network link, etc. It is the only Pajé
object that holds other objects, including containers, which makes it
the main component to define the type hierarchy.  

*State*: A state is used to describe periods of time where a container
stays at the same state, like a thread that is blocked, for
example. It always has a beginning and an ending timestamp.

*Event*: An event has only one timestamp, and can be anything
noteworthy to be uniquely identified.

*Variable*: A variable entity represents the progression of the value
of a variable along the time. A variable is represented by an object
with a value and two timestamps, beginning and end, indicating how
long the variable had that specific value. One determined type of
variable can have several objects according to the changes on its
value.

*Links*: A link represents a relationship between two containers,
such as a communication between processes. It contains two timestamps
specifying the beginning and the end of the communication.

The Pajé objects must be organized as a type hierarchy, where each
entity is always associated with a type. This hierarchy is specific
for each trace file, although it can be repeated in traces with the
same scenario. In the structure of the trace file, the type hierarchy
comes after the event definition where each type of the program is
defined and one of the fields is always the parent type. The
containers are the base for the organization of the hierarchy, being
considered the nodes of the tree, while the other entities are the
leaves. The containers must follow the same precedence as the types
definition. For example, if the container C1, of type T1, is the
parent of the container C2, of type T2, the type T2 must be below T1
in the type tree. The root type is the number "0".

*** Event Definition

The format of the event definition part has the following format:

- Every line of the event definition part of the Pajé format starts
  with the character "%".
- An event definition starts with "%EventDef" plus the =name= of the
  event followed by a =unique number= to identify it.
- An event definition ends with "%EndEventDef".
- Between the "%EventDef" and "%EndEventDef" lines there is a list of
  fields, one per line, with =name= and =type=.
- It is possible to have two events with the same name but different
  identification numbers. This is useful to specify different sets of
  fields for the same type of event.

The types of fields can be: 

=date=: a double precision floating-point number, which usually means
the seconds since the program started;

=int=: integer number;

=double=: floating-point number;

=hex=: address in hexadecimal;

=string=: string of characters;

 =color=: a sequence of three to four floating-point numbers between 0
and 1 inside double quotes. The values mean red, green, blue and
alpha(optional).

An example of event definition: 

#+BEGIN_EXAMPLE
%EventDef PajeNewEvent 17
%       Time date
%       Container string
%       Type string
%       Value double
%EndEventDef
#+END_EXAMPLE


*** Events
\label{subsection.events} 

After the event definition, the events themselves are described, one
in each line. Every event starts with the number that identifies it,
which was defined previously. For the example above, every line that
contains a =PajeNewEvent= event will start with the number 17. The
fields are separated by space or tab and must appear in the same order
as it was declared in the definition. In the example below, there is a
PajeNewEvent event with timestamp =3.14532=, of type =S=, in the
container =p1=, and with value =M=:

#+BEGIN_EXAMPLE
17 3.14532 p1 S M
#+END_EXAMPLE

Fields of type =string= don't need to be double quoted unless they are
empty or have a space or tab character. Before the entities can be
created, a hierarchy of types and containers must be defined and
containers need to be intantiated, since every entity belongs to a
container.

**** Types
Type doesn't have a timestamp and can be declared at anytime in a
trace file, as long as it is not used before its definition. It is
more common to have all the types defined in the beginning. There are
6 different type definitions, one for each sort of entity and one for
value objects:

=PajeDefineContainerType=: Must have the fields _Name_ and _Type_, and
can have an optional field _Alias_. Defines a new container type
called _Name_, contained in a previously defined container of type
_Type_.

=PajeDefineStateType=: Must have the fields _Name_ and _Type_, and can
have an optional field _Alias_. Defines a new state type called
_Name_, contained in a previously defined container of type _Type_.

=PajeDefineEventType=: Must have the fields _Name_ and _Type_, and can
have an optional field _Alias_. Defines a new event type called
_Name_, contained in a previously defined container of type _Type_.

=PajeDefineVariableType=: Must have the fields _Name_, _Type_ and
_Color_, and can have an optional field _Alias_. Defines a new
variable type called _Name_, contained in a previously defined
container of type _Type_, with the color _Color_. Notice that the
color is associated to the type, and not to the object. Therefore,
every variable of determined type will have the same color.

=PajeDefineLinkType=: Must have the fields _Name_, _Type_,
_StartContainerType_ and _EndContainerType_, and can have an optional
field _Alias_. Defines a new link type called _Name_, contained in a
previously defined container of type _Type_, that connects the
previously defined container type _StartContainerType_ to the
previously defined _EndContainerType_. Also, the container type given
in _Type_ must be an ancestral of both start and end container types.

=PajeDefineEntityValue=: Must have the fields _Name_, _Type_ and
_Color_, and can have an optional field _Alias_. This is an optional
event that defines the possible values of an entity type, which can be
a State, Link or Event. Defines a new value called _Name_ for the
previously defined type _Type_ with color _Color_. Notice that this
value is an entity, differently from the one indentifying a variable,
which is a double value.

**** Containers
Intances of containers can be created and destroyed during the trace
file. A container cannot be referenced after it was destroyed. The
events associated to the containers are timestamped.

=PajeCreateContainer=: Must have the fields _Time_, _Name_, _Type_ and
_Container_, and can have an optional field _Alias_. Creates, at
timestamp _Time_, a container instance called _Name_, of the container
type _Type_ and that is a child of the previously created container
_Container_.

=PajeDestroyContainer=: Must have the fields _Time_, _Name_ and
_Type_. Destroys, at timestamp _Time_, a container instance called
_Name_, of the container type _Type_.

**** States
The state events change the values of a determined container's state,
by setting, pushing, popping and reseting.

=PajeSetState=: Must have the fields _Time_, _Type_, _Container_ and
_Value_. Changes, at timestamp _Time_, to the value _Value_, the state
type _Type_, of the container identified by _Container_.

=PajePushState=: Must have the fields _Time_, _Type_, _Container_ and
_Value_. Pushes, at timestamp _Time_, the value _Value_ of the state
type _Type_, in the container identified by _Container_. The push event
saves the existing value of the same state.

=PajePopState=: Must have the fields _Time_, _Type_ and
_Container_. Pops, at timestamp _Time_, the last state of type _Type_
in the container identified by _Container_.

=PajeResetState=: Must have the fields _Time_, _Type_ and
_Container_. Clears, at timestamp _Time_, the state of type _Type_ in
the container identified by _Container_. If the stack is empty, the
event does nothing.

**** Events
An event is something that is relevant enough to be acknowledged and
has a unique timestamp.

=PajeNewEvent=: Must have the fields _Time_, _Type_, _Container_ and
_Value_. Instantiates, at timestamp _Time_, a remarkable event of type
_Type_, in the container _Container_, with value _Value_.

**** Variables
Variables are set at a specific timestamp and can have its value
changed throughout the simulation. The value of a variable is a double
precision floating-point number, which is different from the values of
the other entities. A variable must be set before changes to its value
can be made.

=PajeSetVariable=: Must have the fields _Time_, _Type_, _Container_
and _Value_. Instantiates, at timestamp _Time_, a variable of type
_Type_, in the container _Container_, with value _Value_.

=PajeAddVariable=: Must have the fields _Time_, _Type_, _Container_
and _Value_. Adds, at timestamp _Time_, a value _Value_, to an existing
variable of type _Type_, in the container _Container_.

=PajeAddVariable=: Must have the fields _Time_, _Type_, _Container_
and _Value_. Subtracts, at timestamp _Time_, a value _Value_, of an
existing variable of type _Type_, in the container _Container_.

**** Links
A link can start at a container and end in another one. Every
completed link is identified by a unique key.

=PajeStartLink=: Must have the fields _Time_, _Type_, _Container_,
_StartContainer_, _Value_ and _Key_. Indicates, at timestamp _Time_,
the beginning of a link of type _Type_, in container _Container_,
starting from _StartContainer_, with value _Value_, and identified by
key _Key_.

=PajeEndLink=: Must have the fields _Time_, _Type_, _Container_,
_EndContainer_, _Value_ and _Key_. Indicates, at timestamp _Time_, the
end of a link of type _Type_, in container _Container_, ending in
_EndContainer_, with value _Value_, and identified by key _Key_.


** PajeNG

The PajeNG implementation is the new generation of the Pajé
Visualization Tool. It was developed in C++ and follows the same
architecture as the original Pajé. It comprises a library containing
the core of the simulation, a space-time visualization tool and some
auxiliar tools to manage the trace files. The visualization component
was not considered in this proposal and the base for the
implementation of this project was the =libpaje= library. The library
has three main components forming a pipeline that results in complete
simulated entities. These components are: FileReader, EventDecoder and
PajeSimulator. First, the FileReader reads an event from the trace
file. Then, the EventDecoder identifies what is the event being
processed and created an object with all the necessary
information. Last, the PajeSimulator receives this event object and
addresses to the proper simulation.

(image from paje-parco)

Pajé was idealized to be extensible, specially in terms of creating
new types of events. Actually, the Pajé format itself is very
expandable, which makes it necessary to build a simulator
accordingly. This flexibility is implemented by an hierarchy of
classes, going from the most general, containing the basic fields
common to every type and entity, to the most specific. There
are three main hierarchies that are particularly important in this
objective: one for events, one for types and one for entities. With
this modular implementation, it is relatively easy to add a new type
of event or entity and integrate it with the rest of the code.

An event object is what is passed as an argument to the simulator so
that it can be processed. Therefore, it must contain all of the
necessary information for the simulation. The first object created
when a trace file is being parsed is of type =PajeTraceEvent=, which
is a class containing all the fields read by the parser. The event
hierarchy starts with a simple =PajeEvent= class. This class has a
trace event object, a container, a type and a timestamp. The imediate
childs of PajeEvent are: =PajeCategorizedEvent=, =PajeVariableEvent=
and =PajeDestroyContainerEvent=. The variable event is the parent of
the specific events for variables, which are set, add and subtract. A
categorized event is characterized by having a =PajeValue= associated
to it, thus, =PajeStateEvent=, =PajeEventEvent=, =PajeLinkEvent=, and
their respective childs inherit from it.

(image of event hierarchy)

The first class of the type hierarchy is the =PajeType=. It has a
name, an alias and a parent type, which is also a PajeType. These
fields are the ones common to all the type definition events described
in section \ref{section.pajeformat}. The immediate childs of this
class are: =PajeCategorizedType=, =PajeVariableType= and
=PajeContainerType=. As the events, the categorized types are
associated to a value, hence, the PajeCategorizedType has a PajeValue
field and methods to manipulate it. Its childs are the
=PajeStateType=, =PajeEventType= and =PajeLinkType=.

(image of type hierarchy beginning in pajetype)

The =PajeEntity= is the first node of the entities tree. It origins a
=PajeSingleTimedEntity= class, that describes entities with one single
timestamp. The =PajeUserEvent= is the only entity with this
characteristic, but it is possible to add, in the future, more
entities with just one timestamp. The =PajeDoubleTimedEntity= inherits
from this class and represents entities with start and end
timestamps. Like the other hierarchies, the valued entities are
grouped together so a =PajeValueEntity= is a child of the double timed
entity, having =PajeUserState= and =PajeUserLink= as descendents. The
double timed entity also has =PajeUserVariable= and =PajeNamedEntity=
as childs. A =PajeContainer= inherits from the named entity.

(image of entities hierarchy beginning in PajeEntity)

All the simulation is performed in two classes: =PajeSimulator= and
=PajeContainer=. A PajeSimulator object is instantiated in the
beginning of the program and incorporates all the event processing of
the simulation. The type definitions, container creations and entity
value declarations are completed and stored in the PajeSimulator
object. Everytime there is an event of type =PajeCreateContainer=, a
PajeContainer object is instantiated. All other events are always
associated to a container, thus, they will be simulated in the
appropriate container instance. The PajeContainer object will keep the
entities until it is destroyed or the program finishes. Since all the
data from the simulation is kept in memory, the end timestamp is used
to sinalize that an entity is no longer available to the program.

(image Paje Simulator and PajeContainer relation)


The PajeSimulator class lists every type declared and container
created throughout the simulation by using map structures:

=typeMap=: a map containing all the types that have been defined in
the simulation, with name or alias as key;

=contMap=: a map of the created containers also identified by the name
or alias.

In the simulator, there is always a pointer to the root type and
 another to the root container initialized in the beginning of the
 program. The simulator contains one method for each type of event
 described in section \ref{subsection.events}, which perform all the
 validations, besides the processing itself. Whenever there is an
 event that defines a type, such as =PajeDefineContainerType=, the
 entity generated is added to the =typeMap=. When an event related to
 a container is being simulated, the container in question is found in
 =contMap= and the proper method of the container object is called.

The PajeContainer class stores in map structures all the entities that
are related to it including other containers:

=stackStates=: a map identified by the type and with a vector of state
entities as the value. Every event of type =PajePushState= will add a
state entity to the end of the stack, while every =PajePopState= will
"remove" the last state in the vector by setting its end time;

=pendingLinks=: a map of pending links stores the communications that
were opened but have not been closed yet. The link key is the
identification, and the simulation fails if a container is destroyed,
or the simulation ends, before all the links are completed;

=linksUsedKeys=: a map listing all the keys for links that were
already used in this container.

=entities=: This map lists all the entities that belong to the
container, even if they were already listed in the other
structures. What identifies an entity is its type and container,
hence, the PajeType is the key of this map and a vector of entities is
the value. Here, we notice the importance of having the single parent
type class PajeType, and a unique parent entity class, PajeEntity, to
group together different types of objects. Since the objects are
pointers, the changes made in one structure are reflected in the other
ones. All of the variable and event objects are stored in this general
list of entities.

The PajeContainer class contains a method for each event that is
associated to a container, adding and removing entities of these
structures listed above. 

** Issues of PajeNG

The focus of the Paje implementation is to allow the user to extend
the Pajé format and adapt the simulator to it. When thinking about the
handling of the simulated data, it is not very straightforward. One of
the modules of PajeNG is the tools module, which contains the
=pj_dump= functionality. The PajeSimulator instance maintains all of
the simulated entities in memory, and the dump tool throws to the
standard output all the information about each entity stored. If a
user wants to see the resulted entities during the simulation, he
would need to get into the PajeSimulator code to make the necessary
changes. Techincally, since all the results are stored in memory, it
would be simple to add a new functionality, but it is limited to
manipulation of the whole set of results, not each entity
separatedly. Also, there is the need of understanding the classes and
its hierarchies in order to build a module to the program. Another
problem with this implementation is the ephemerality of the results,
since it is kept in memory during simulation and then discarded at the
end.

Based on these issues, an extensible simulator written in Java was
developed. The proposed program contains instrumentation points which
allow the creation of plugins attached to it. For example, if one
wants to handle only state entities, he can create a plugin attached
only to the points that are related to states. The other entities
created will be discarded by the simulator. The problems listed above,
besides the difficulty in extending the simulator, were solved with
the creation of plugins. The details of the implementation are in the
next two chapters.


* Aiyra - Java-based simulator
\label{chapter.aiyra}

+ Overview
     - extensible, java, problems solved, structure, image.
   + option handling
     - library 
     - one class to make it easier to the user
   + Parsing 
     - JavaCC, why, grammar
   + simulation
     - same structure as PajeNG, why? because it was working. not
       reduce the extensibility, just add more. 
     - technical differences
       - not optional fields
   + plugins
     - PajePlugin class
     - instrumentation points
   + how to compile and execute
     - basic options to execute - filename, comment, platform

Aiyra is an extensible simulator written in Java that reads trace
files in the Pajé format and, instead of storing the results in
memory, forwards every created entity to a common place where it
can be manipulated freely.

** Processing Command Line Arguments 

Since handling command line arguments is not very straightforward in
Java, an external library \cite{optionhandler} was used. The command
line arguments are used for the user to pass information to the
simulator, such as the name of the file to be processed, or a comment
about the trace.

All of the arguments processing is done in one class:
=OptionsHandler=. The options that are needed in the simulation core
are stored in this single class. These are: 

*filename*: a string that receives the name of the trace file to be
read;

*comment*: a string that stores an optional comment about the file;

The centralization of the options has the objective of facilitating
the extensibility of the program. The arguments regarding a specific
plugin are sent directly to its proper object.

The constructor of this class receives the list of arguments that was
passed in the execution of the program and creates an object =opt= of
type =Options= with the arguments as parameter. 

#+BEGIN_EXAMPLE
import ml.options.Options;

public class OptionsHandler {

  public Options opt;

  public OptionsHandler(String args[]) {
	  opt = new Options(args);	
  }
}

Options opt
#+END_EXAMPLE

The Options type is the core of the library used, and all of the argument's
processing will be done in the =opt= instance. It is also in the
constructor that we set all of the possible options that can be used
by the user. To define a new one, we use the following line of
code:

#+BEGIN_EXAMPLE
opt.getSet().addOption("<alias>", Options.Separator.<SEPARATOR>, Options.Multiplicity.<MULTIPLICITY>);
#+END_EXAMPLE

=<alias>=: the alias that will be used to identify the option;

=<SEPARATOR>=: used for options that have a value. Can be *COLON*,
*EQUALS*, *BLANK* or *NONE*;

=<MULTIPLICITY>=: the multiplicity defines if the value is required or
optional, or if it can appear more than once. The possible values are:
*ONCE*, *ONCE_OR_MORE*, *ZERO_OR_ONE*, *ZERO_OR_MORE*.


The default for the prefix is a dash and is the one chosen for the
program. The constructor of Aiyra's OptionsHandler class has the
following definitions:

#+BEGIN_EXAMPLE
opt.getSet().addOption("f", Options.Separator.BLANK, Options.Multiplicity.ONCE);
opt.getSet().addOption("m", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);
opt.getSet().addOption("p", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);		
#+END_EXAMPLE

=-f=: required field that indicates the file to be parsed;

=-m=: an optional comment about the trace;

=-p=: the plugin to be used by the simulator.

To check if the user has passed the arguments properly, the Options
class provides a simple method thet returns a boolean:

#+BEGIN_EXAMPLE
opt.check
#+END_EXAMPLE

In the OptionsHandler class, this verification is done in the
=checkOptionsHelper= method, which prints a helper text to the user in
case the check fails.

#+BEGIN_EXAMPLE
public void checkOptionsHelper() {
	// true=ignoreUnmatched false=requireLast
	if (!this.opt.check(true, false)) {
		System.out.println("Your input is incorrect");
		System.out.println("Please use the following notation:");
		System.out.println("-f <path-to-filename>");
		System.out.println("-m <comment> (optional)");
		System.out.println("-p <plugin> (optional, default: null) ");
			
		System.exit(1);
	}
}
#+END_EXAMPLE

This validation must be done before the program continues, thus, this
method is already called in the constructor:

#+BEGIN_EXAMPLE
 public OptionsHandler(String args[]) {
	  opt = new Options(args);

      opt.getSet().addOption("f", Options.Separator.BLANK, Options.Multiplicity.ONCE);
      opt.getSet().addOption("m", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);
      opt.getSet().addOption("p", Options.Separator.BLANK, Options.Multiplicity.ZERO_OR_ONE);

      checkOptionsHelper();	
  }
#+END_EXAMPLE 

** Parsing 

To parse the Pajé trace files, the JavaCC 
  
* Plugins
\label{chapter.plugins} 

To validate the concept of the plugins, two were implemented:
=PajeDumpPlugin= and =PajeIsertDBPlugin=. Also, there is a default
plugin, the =PajeNullPlugin=, that does not make any treatment to the
data so it is simply discarded. It is useful to verify the performance
of the simulation itself, whothout the interference of the other
segments.

** Paje Dump Plugin

The Dump plugin just outputs 



* Performance Evaluation
 \label{chapter.performance}
* Conclusion
\label{chapter.conclusion}

#+LATEX: \bibliography{References}
