* Introduction
Observation of program behavior is particularly important in High Performance Computing since it enables an accurate performance analysis. A very common method of evaluation is registering program events in trace files that work as a log, so, whenever a relevant event happens, it will be logged in the trace file with the proper information. Then, these traces are replayed in simulation combining information that is spread across multiple events deriving new and richer entities. This event processing is usually done once and discarded, which can be very incovenient considering that some trace files are very large. Therefore, it would be intersting to save these entities for further analysis.  

In this context of performance analysis, a common tool used is the Pajé Trace Simulator, an open source project that reads trace files in a specific format, Pajé Trace File Format, and processes five types of entities: Containers, States, Events, Variables and Links. These concepts represent basic structures of computer programs executed in parallel or distributed systems, such as processes, threads, network links, variables and so on. As a base for the implementation of this proposal, the new generation of Pajé, PajeNG, was used. Details of PajeNG, the types of entities and the Pajé File Format will be presented in Chapter 3. Although it has a visualization functionality, we will focus on the simulation part of the Pajé implementation in this project. The most commonly used tool of PajeNG is the Paje Dump (pj_dump), that dumps the main information of all the entities created throughout the simulation to the standard output. 

There are at least three problems with the current implementation of Pajé: little extensibility, lack of partial outcomes and impermanent results. It is very complicated to change the Paje simulator behavior, since it requires code modifications in the simulator core, which depends upon understanding details of the program. If a performance analyst wants to evaluate only one type of entity, or needs a different presentation of the data, he will need to have at least a basic understanding of how the program is implemented in order to generate these different results. Throughout the simulation, the Pajé tool creates entities according to the events listed in the trace file, saving each one of them in memory to dump everything at once in the end. Since some trace files can be very large (over 1 Gigabyte), it may take a while for the results to be printed out. Besides not being able to have a partial view of already simulated entities, the user won`t have records of the results between executions for different files unless he specifies a destination for it himself. To address these issues, an extensible trace files simulator, Aiyra, was developed in Java.

The objective of this proposal is to allow the performance analyst to change the simulator behavior when a new entity is detected. Thus, the partial results can be immediately presented to the user, or saved in a database, or even discarded if not relevant. This extensibility is implemented through the concept of plugins that are attached to the simulator in specific and important points where the trace events are combined. This main objective solves the first problem previously presented, which is the lack of extensibility. Once the simulator allows the immediate manipulation of the entities, the other two issues can be easily addressed with extensions. Hence, the secondary objectives of the project are the creation of plugins to dump partial data that has just been simulated and to make the results permanent. 

For the validation of the extensible trace files simulator, two plugins were implemented: Paje Dump Plugin and Paje Insert Database Plugin. The first one plays the same roll as the original Paje Dump tool in the Paje new generation, with the difference that the entities are dumped at the moment they are completed. The second one inserts all the data in a relational database. A specific schema for the Pajé Format was designed and will be presented in Chapter 5. A performance analysis was developed to compare Aiyra against the previous one. It is worth highlighting that the new simulator had better performance results with bigger files (over 120 Megabytes), that being possibly attributed to the fact that it discards from memory entities that will no longer be used. Additionally, the Pajé Insert Database plugin was evaluated comparing its different possibilities of usage. In this investigation, we varied the frequency of the insertions in the database by grouping queries in memory until it had a specific size to insert. The objective of this test was to understand the impact of an access to a database in the performance of the program. Likewise, the usage of the memory was also examined to determine the best balance between excution time and memory management. As we will see in Chapter 6, the memory usage had more impact in the performance than the accesses to the database themselves, probably due to the Garbage Collector mechanism used by Java.

* Basic Concepts
In this Chapter, the basic concept of the technologies used to develop this project will be presented to guarantee a full understanting of all the process.

** JavaCC

The first part of Aiyra simulator consists in reading a trace file, that is in a specific standard, and parsing it to define how each line of the entry will be simulated. For that, a lexical and parser generator, called Java Compiler Compiler (JavaCC), was used. JavaCC behaves similarly to Flex and Bison, receiving a set of regular expressions describing the tokens of the language and a grammar defined using these tokens. The output of the generator is a lexical analyser, that separates the input file into tokens, and a parser, which performs a syntax analysis. What differentiates JavaCC from other parser generators that exist for the Java language is that it creates files written in pure Java, which facilitates the understanding and eliminates the need of having dependencies in the code. JavaCC has also shown itself to have a much better performance than other tools such as ANTLR (Another Tool For Language Recognition), that requires a runtime library. 

JavaCC can be downloaded, unziped and added to the PATH. It also has a plugin for Eclipse. Once installed, JavaCC will process your grammar defined in a file with extension ".jj" using the command "javacc". As an example, I will use MyGrammar.jj. The result of the processing are seven files: 
 =MyGrammar.java=: The parser;
 =MyGrammarTokenManager.java=: The lexical analyser, that manages the tokens;
 =MyGrammarConstants.java= : Some useful constants. 

The other four files generated: =Token.java=, =TokenMgrError.java=, =SimpleCharStream.java= and =ParseException.java= are boilerplate files that can be reused within parsers and are not affected by the grammar itself.
Once having ".java" files, it is possible to compile them using "javac" as usual. 

*** Structure and syntax

The whole grammar will be in the =MyGrammar.jj= file and it is the only file that needs to be modified. There, the tokens used will be defined, the parser rules specified, and it is possible to even add Java code that has to be executed during the parsing. The structure of this file is the following: 

options{
}

A set of optional flags. An example, is the flag STATIC, which means that there is only one parser for the JVM when set to true. 

PARSER_BEGIN(MyGrammar)

public class MyGrammar {

}

PARSER_END(MyGrammar)

In this part, the Java code will be placed and it's the main class of the program. Notice that the class must have the same name as the generated parser. 

TOKEN_MGR_DECLS:
{

}

The declarations used by the lexical analyser are placed in the TOKEN_MGR_DECLS function.

Below these three structures, comes the lexical analysis where the Token rules and parser actions can be written using a top-down approach. First, the Tokens are declared, always using the word "TOKEN" before. To exemplify the creation of a grammar in JavaCC, we will create a language that consists in the declaration of integer and char variables and assignments of values to these variables. All the declarations come first, then the assignments. No verification will be performed since it is just an example to clarify the JavaCC syntax. To declare tokens, we use the following notation: 

TOKEN: 
{
  < [NAME] : [EXPRESSION] >  
}

For our example of language we will have the following tokens: 

/* Integer Literals */
TOKEN : 
{
  < INTEGER: "0" | ["0"- "9"] (["0"-"9")* >
}

/*Variables, assignments and char values*/
TOKEN : 
{
  < VARIABLE: (["a"-"z", "A" - "Z"])+ >
  < ASSIGNMENT: "=" >
  < CHAR: (~["\""] | "\\" (["n","r","\\","\'","\""])) >
} 
/* Types */
TOKEN: 
{
  < INTEGER_TYPE : "int" >
  < CHAR_TYPE: "char" >
}

As we can see in the definitions above, it is not necessary to explicit the word TOKEN for each one. It is usually separated to be better organized and easier to understand. Although the token's agroupation is not relevant, the order in which they are declared is. When an input matches more than one token specification, the one declared first will be considered.
There is also another kind of regular expression production, which is the SKIP. Whatever matches the regular expression defined in the SKIP scope will not be treated by the parser. 
Example: 

#+BEGIN_EXAMPLE
SKIP: 
{
  "\n" 
  \| "\t"

} 
#+END_EXAMPLE

After the token declaration, comes the grammar rules. The rules are declared as methods, that can have return values or not. The structure of a method is the following: 

#+BEGIN_EXAMPLE
[type] [name] ()
{}
{ 
  /* Rules */
}
#+END_EXAMPLE


The empty braces in the beginning of the method can be filled with variable declarations in Java. More Java code can be added in the middle of the rules by using braces. Inside the next braces, it is possible to assign tokens, regular expressions or even methods to the variables declared earlier. To refer to the tokens, we use its name between angular brackets. Example: 

void parser()
{ int number; }
{
  number = <INTEGER>
}

The first method defined will be the entrance to the parser and it can contain methods inside that will be expanded later in the rules. The entrance for the language we are using as an example would be as follows: 

void start()
{}
{
  declarations() assignments() <EOF>
}

EOF is a default token. It is important to guarantee that the file will be parsed until the end. By the definition of our first method, we assure that the declarations will obligatorily be in the beginning, and the assignments at the end. Next, we expand the two methods to address all the possibilities: 

void declarations()
{}
{
  ((<INTEGER_TYPE> | <CHAR_TYPE>) <VARIABLE>)*
}

void assignments()
{}
{
  (<VARIABLE> <ASSIGNMENT> (<CHAR> | <INTEGER>))*
}

The multiplicity can be defined with the standard characters "*", "?", "+", just as in the lexer. This example is just one possible approach to define these rules. For example, you can use another non-terminal to describe a value that will be assigned to a variable. In this case, the assignments() rule would be expanded as follows: 

void assignments()
{}
{
  (<VARIABLE> <ASSIGNMENT> assignable() )*
}

void assignable():
{}
{
  <CHAR> | <INTEGER> 
}

*** Usage with Java

In order to call the parser in a Java program, an object of the MyGrammar class needs to be instantiated: 

MyGrammar parser = new MyGrammar(input);

Then, once there is an instance of the parser, it is possible to call the first method of the parser:

parser.start();

This code has a Java syntax and is placed in the main class presented previously. Between the declarations of PARSER_BEGIN and PARSER_END, any Java code can be placed to manipulate the results of the parsing.  

PARSER_BEGIN(MyGrammar)
/* Imports */
public class MyGrammar {
    public static void main(String args []){
        /* Code to read the input */

        MyGrammar parser = new MyGrammar(input);
        parser.start();

       /* Java code to manipulate the parser results */
	
  }

}

PARSER_END(MyGrammar)

** Experimental Design

For the performance evaluation, we used the technique of experimental design, which is a form of performance analysis that aims to define a minimum number of experiments that will collect the maximum information necessary. It also targets random variations that could affect the results, guaranteeing that the number of tests executed and the error margin calculated will be suficient to avoid misleading conclusions.

*** Terminology
The terminology used in experimental design is the following: 

=Response Variable=: The response variable is the outcome of an experiment;
=Factors=: The factors are all the variables that could have several different values affecting the response variable; 
=Levels=: The levels are the possible values that a factor can assume;
=Primary Factors=: The primary factors are the factors that need to be quantified;
=Secondary Factors=: The secondary factors are the factors whose impacts in the performance are not relevant for the analysis;
=Replication=: Replication is the repetition of all or some experiments;
=Design=: The experimental design is the specification of total number of experiments, based on factor level combination and number of replications for each experiment.
=Experimental Unit=: The experimental unit is th entity used for the experiment, for example, a computer;
=Interaction=: Interaction is when the levels of a fator affect the results of other factor.

*** Full Factorial Design

There are several types of experimental design modeling. In this project, we used a full factorial design, which consists in analysing every possible combination at all levels of all factors. With this type of design, it is possible to evaluate factor that have different numbers of levels. The advantage of this model is that every possible combination will be analysed, generating richer results. However, depending on the number of factors, levels and replications, it may generate a very large total number of experiments, which can cost a lot of time. Therefore, when using this technique, it is important to weight the relevance of each factor and level to generate an appropriate and accurate design. To calculate the total size of the sample you multiply the numbers of levels of the factors and the number of replications. For example, a design with a three-level factor and a two-level factor with 20 replications would have 120 experiments.

** R language

R is a language for statistical computing and graphics generation. It can be very easily extended, by creating and using packages. For this work, the "DoE.base" and "ggplot" packages were used. 

**** Doe.base

DoE.base is a package to generate full factorial experimental designs. It contains the class _design_ with several accessor functions to create different types of design. One particular important function is the _fac.design_, which creates full factorial designs with arbitrary numbers of levels. The function receives several arguments, including number of factors, levels and replication. The usage of the function is the following: 

#+begin_src R :results output silent :session :exports none
  require(DoE.base);
  fac.design (
           nfactors=NULL,
           replications=1,
           repeat.only=FALSE,
           blocks=1,
           randomize=TRUE,
           seed=NULL,
           nlevels=NULL,
           factor.names= NULL )
#+end_src

=nfactors=: The number of factors;
=replications=: The number of replications;
=repeat.only=: If true, replications of each run are grouped together;
=blocks=: Number of blocks in which the experiment wil lbe subdivided. Must be a prime;
=randomize=: If true, the design is randomized;
=seed=: seed For the randomization (optional);
=nlevels=: A vector with the number of levels for each factor;
=factor.names=: A list of vectors with factor levels. 

**** ggplot


* Pajé Visualization Tool - PajeNG 

The Pajé Visualization Tool is a tool to display the execution of parallel and distributed programs. The tool reads information from trace files that describe the important events in the execution of a parallel program. This implementation plots the simulation of trace files in the Pajé Trace File Format, which is described below. 

** Pajé Trace File Format

The Pajé Trace File Format is a textual and generic format that describes the behavior of paralell and distributed programs. This format contains three sections: event definition, type hierarchy declaration and timestamped events. As mentioned before, the Pajé format describes five types of entities: Containers, States, Events, Variables and Links. Each entity is always associated to a container, even the containers themselves. Below, a succint definition of each type of entity:

=Container=: A container can be any hardware or software entity, such as a processor, a thread, a network link, etc. It is the only Pajé object that holds other objects, including containers, which makes it the main component to define the type hierarchy. 
=State=: A state is used to describe periods of time where a container stays at the same state. It always has a beginning and an ending timestamp.
=Event=: An event has only one timestamp, and can be anything noteworthy to be uniquely identified. 
=Variable=: A variable entity represents the progression of the value of a variable along the time. A variable is represented by an object with beginning and ending timestamps and one determined type of variable can have several objects according to the changes on its value.
=Links=: A link has beginning and ending timestamps and represents a relation between two containers, such as a communication between processes.

The Pajé objects must be organized as a type hierarchy, where each entity is always associated with a type. This hierarchy is specific for each trace file, although it can be repeated in traces with the same scenario. In the structure of the trace file, the type hierarchy comes after the event definition where each type of the program is defined and one of the fields is always the parent type. The containers are the base for the organization of the hierarchy, being considered the nodes of the tree, while the other entities are the leaves. The containers must follow the same hierarchy as the types definition. For example, if the container C1, of type T1, is the parent of the container C2, of type T2, the type T2 must be below T1 in the type tree. The root type is the number "0".

*** Event Definition

The format of the event definition part has the following format: 

- Every line of the event definition part of the Pajé format starts with the character "%".
- An event definition starts with "%EventDef" plus the =name= of the event followed by a =unique number= to identify it.
- An event definition ends with "%EndEventDef". 
- Between the "%EventDef" and "%EndEventDef" lines there is a list of fields, one per line, with =name= and =type=. 
- It is possible to have two events with the same name but different identification numbers. This is useful to specify different sets of fields for the same type of event.

The types of fields can be: 
=date=: a double precision floating-point number, which usually means the seconds since the program started;
=int=: integer number;
=double=: floating-point number;
=hex=: address in hexadecimal;
=string=: string of characters;
=color=: a sequence of three to four floating-point numbers between 0 and 1 inside double quotes. The values mean red, green, blue and alpha(optional).

An example of event definition: 

%EventDef PajeNewEvent 17
%       Time date
%       Container string
%       Type string
%       Value double
%EndEventDef

*** Events 

After the event definition, the events themselves are described, one in each line. Every event starts with the number that identifies it, which was defined previously. For the example above, every line that contains a PajeNewEvent event will start with the number 17. The fields are separated by space or tab and must appear in the same order as it was declared in the definition. In the example below, there is a PajeNewEvent event with timestamp =3.14532= of type =S= in the container =p1= and with value =M=:

17 3.14532 p1 S M

Fields of type =string= don't need to be double quoted unless they are empty or have a space or tab character. Before the entities can be created, a hierarchy of types and containers must be defined and containers need to be intantiated, since every entity belongs to a container.

**** Types
Type doesn't have a timestamp and can be declared at anytime in a trace file, as long as it is not used before its definition. It is more common to have all the types defined in the beginning. There are 6 different type definitions, one for each sort of entity and one for value objects: 

=PajeDefineContainerType=: Must have the fields _Name_ and _Type_, and can have an optional field _Alias_. Defines a new container type called _Name_, contained in a previously defined container of type _Type_. 
=PajeDefineStateType=: Must have the fields _Name_ and _Type_, and can have an optional field _Alias_. Defines a new state type called _Name_, contained in a previously defined container of type _Type_.  
=PajeDefineEventType=: Must have the fields _Name_ and _Type_, and can have an optional field _Alias_. Defines a new event type called _Name_, contained in a previously defined container of type _Type_.
=PajeDefineVariableType=: Must have the fields _Name_, _Type_ and _Color_, and can have an optional field _Alias_. Defines a new state type called _Name_, contained in a previously defined container of type _Type_, with the color _Color_. Notice that the color is associated to the type, and not to the object. Therefore, every variable of determined type will have the same color. 
=PajeDefineLinkType=: Must have the fields _Name_, _Type_, _StartContainerType_ and _EndContainerType_, and can have an optional field _Alias_. Defines a new link type called _Name_, contained in a previously defined container of type _Type_, that connects the previously defined container type _StartContainerType_ to the previously defined _EndContainerType_. Also, the container type given in _Type_ must be an ancestral of both Start and End container types.
=PajeDefineEntityValue=: Must have the fields _Name_, _Type_ and _Color_, and can have an optional field _Alias_. This is an optional event that defines the possible values of an entity type, which can be a State, Link or Event. Defines a new value called _Name_ for the previously defined type _Type_ with color _Color_.  

**** Containers
Intances of containers can be created and destroyed during the trace file. The events associated to the containers are timestamped.

=PajeCreateContainer=: Must have the fields _Time_, _Name_, _Type_ and _Container_, and can have an optional field _Alias_. Creates, at timestamp _Time_, a container instance called _Name_, of the container type _Type_ and that is a child of the previously created container _Container_. 
=PajeDestroyContainer=: Must have the fields _Time_, _Name_ and _Type_. Destroys, at timestamp _Time_, a container instance called _Name_ of the container type _Type_.

**** States
The state events change the values of a determined container's state, by setting, pushing, popping and reseting.

=PajeSetState=: Must have the fields _Time_, _Type_, _Container_ and _Value_. Changes, at timestamp _Time_, to the value _Value_ the state type _Type_ of the container identified by _Container_.
=PajePushState=: Must have the fields _Time_, _Type_, _Container_ and _Value_. Pushes, at timestamp _Time_, the value _Value_ of the state type _Type_ in the container identified by _Container_. The push event saves the existing value of the same state.
=PajePopState=: Must have the fields _Time_, _Type_ and _Container_. Pops, at timestamp _Time_, the last state of type _Type_ in the container identified by _Container_.
=PajeResetState=: Must have the fields _Time_, _Type_ and _Container_. Clears, at timestamp _Time_, the state of type _Type_ in the container identified by _Container_. If the stack is empty, the event does nothing.

**** Events
An event is something that is relevant enough to be acknowledged and has a unique timestamp. 

=PajeNewEvent=: Must have the fields _Time_, _Type_, _Container_ and _Value_. Instantiates, at timestamp _Time_, a remarkable event of type _Type_ in the container _Container_ with value _Value_.

**** Variables
Variables are set at a specific timestamp and can have its value changed throughout the simulation. The value of a variable is a double precision floating-point number, which is different from the values of the other entities. A variable must be set before changes to its value can be made.

=PajeSetVariable=: Must have the fields _Time_, _Type_, _Container_ and _Value_. Instantiates, at timestamp _Time_, a variable of type _Type_ in the container _Container_ with value _Value_. 
=PajeAddVariable=: Must have the fields _Time_, _Type_, _Container_ and _Value_. Adds, at timestamp _Time_, a value _Value_ to an existing variable of type _Type_ in the container _Container_.
=PajeAddVariable=: Must have the fields _Time_, _Type_, _Container_ and _Value_. Subtracts, at timestamp _Time_, a value _Value_to an existing variable of type _Type_ in the container _Container_.

**** Links
A link can start at a container and end in another one. Every completed link is identified by a unique key. 

=PajeStartLink=: Must have the fields _Time_, _Type_, _Container_, _StartContainer_, _Value_ and _Key_. Indicates, at timestamp _Time_, the beginning of a link of type _Type_ in container _Container_ starting from _StartContainer_ with value _Value_ and identified by key _Key_.
=PajeEndLink=: Must have the fields _Time_, _Type_, _Container_, _EndContainer_, _Value_ and _Key_. Indicates, at timestamp _Time_, the end of a link of type _Type_ in container _Container_ ending in _EndContainer_ with value _Value_ and identified by key _Key_.

** PajeNG

The PajeNG implementation is the new generation of the Pajé Visualization Tool. It was developed in C++ and follows the same architecture as the original Pajé. It comprises a library containing the core of the simulation, a space-time visualization tool and some auxiliar tools to manage the trace files. 
As mentioned before, the visualization component was not considered in this proposal and the =libpaje= library was used as a base to the implementation. The library has three main components that form a pipeline that results in complete simulated entities. These components are: FileReader, EventDecoder and PajeSimulator. First, the FileReader reads from the trace file the event, it can be done either by Flex and Bison or a regular C++ parsing, it is the user's choice. Then, the EventDecoder identifies what is the event being processed and created an object with all the necessary information. Last, the PajeSimulator receives this event object and addresses to the proper simulation.
(image?)
All the simulation is done in two classes: PajeSimulator and PajeContainer. A PajeSimulator object is instantiated in the beginning of the program and incorporates all the event processing of the simulation. All the type definitions, container creations and entity value declarations are completed in the PajeSimulator object. Everytime there is an event of type _CreateContainer_, a PajeContainer object is instantiated. All other events are always associated to a container, thus, they will be simulated in the appropriate container object. This object will keep the entities until it is destroyed or the program finishes.

(image?)

Details about the implementation? stack of states, maps, etc.   






  
  
