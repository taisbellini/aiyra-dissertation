* Introduction
Observation of program behavior is particularly important in High Performance Computing since it enables an accurate performance analysis. A very common method of evaluation is registering program events in trace files and then replaying them in a simulation. During this process, information spread in multiple events is combined deriving new and richer entities. This event processing is usually done once and discarded, which can be very incovenient considering that some trace files are very large. Therefore, it would be intersting to save these entites for further analysis.  

In this context of performance analysis, a common tool used is the Pajé Trace Simulator, an open source project that reads trace files in a specific format (Pajé File Format) and generates five types of entities: Containers, States, Links, Variables and Events. As a base for the implementation of this proposal, the new generation of Pajé, PajeNG, was used. Details of PajeNG, the types of entities and the Pajé File Format will be presented in chapter 3. Although it has a visualization functionality, we will focus on the simulation part of the Pajé implementation in this project. The most commonly used tool of PajeNG is the Paje Dump (pj_dump), that dumps the main information of all the entities created throughout the simulation to the standard output. 

There are at least three problems with the current implementation of Pajé: little extensibility, lack of partial outcomes and impermanent results. It is very complicated to change the Paje simulator behavior, since it requires code modifications in the simulator core, which depends upon understanding details of the program. If a performance analyst wants to evaluate only one type of entity, or needs a different presentation of the data, he will need to have at least a basic understanding of how the program is implemented in order to generate these different results. Throughout the simulation, the Pajé tool creates entities according to the events listed in the trace file, saving each one of them in memory to dump everything at once in the end. Since some trace files can be very large (over 1 Gigabyte), it may take a while for the results to be printed out. Besides not being able to have a partial view of already simulated entities, the user won`t have records of the results between executions for different files unless he specifies a destination for it himself. To address these issues, an extensible trace files simulator, Aiyra, was developed in Java.

The objective of this proposal is to allow the performance analyst to change the simulator behavior when a new entity is detected. Thus, the partial results can be immediately presented to the user, or saved in a database, or even discarded if not relevant. This extensibility is implemented through the concept of plugins that are attached to the simulator in specific and important points where the trace events are combined. This main objective solves the first problem previously presented, which is the lack of extensibility. Once the simulator allows the immediate manipulation of the entities, the other two issues can be easily addressed with plugins. Hence, the secondary objectives of the project are the creation of plugins to dump partial data that has just been simulated and to make the results permanent. 

For the validation of the extensible trace files simulator, two plugins were implemented: Paje Dump Plugin and Paje Insert Database Plugin. The first one plays the same roll as the original Paje Dump tool in the Paje new generation, with the difference that the entities are dumped at the moment they are completed. The second one inserts all the data in a relational database. A specific schema for the Pajé Format was designed and will be presented in Chapter 5. A performance analysis was developed to compare Aiyra against the previous one. It is worth highlighting that the new simulator had better performance results with bigger files (over 120 Megabytes), that being possibly attributed to the fact that it discards from memory entities that will no longer be used. Additionally, the Pajé Insert Database plugin was evaluated comparing its different possibilities of usage. In this investigation, we varied the frequency of the insertions in the database by grouping queries in memory until it had a specific size to insert. The objective of this test was to understand the impact of an access to a database in the performance of the program. Likewise, the usage of the memory was also examined to determine the best balance between excution time and memory management. As we will see in Chapter 6, the memory usage had more impact in the performance than the accessed to the database themselves, probably due to the Garbage Collector mechanism used by Java.
  
