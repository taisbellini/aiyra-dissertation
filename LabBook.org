#+TITLE: Bellini's Dissertation LabBook
#+AUTHOR: Lucas e Tais
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Lucas(L) Tais(T) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

* 2015-09-15 Structure / Draft of TCC                            :Lucas:Tais:

1. Introduction (3 pages max)
   + Context (current scenario with pajeng c++)
   + Motivation
2. Basic Concepts? (5 pages max)
   + JavaCC?
   + Ferramentas de análise de desempenho
   + MySQL ? 
3. PajeNG
   + How it is used by others (pjdump, etc)
   + Description of how it works internally
   + The problems with the current approach
     + Focus on your contribution
4. Java Simulator
   + Overview
     - extensible, java, problems solved, structure, image.
   + option handling
     - library 
     - one class to make it easier to the user
     - the general options ONLY
   + Parsing 
     - JavaCC, why, 
     - PajeGrammar,jj file 
       - it is the entry point of the program. 
       - it has java code and the main class
       - it has variables that are global for the whole program 
     - grammar
   + simulation
     - same structure as PajeNG, why? because it was working. not
       reduce the extensibility, just add more. 
     - technical differences
   + plugins
     - PajePlugin class
     - instrumentation points
   + how to compile and execute
     - basic options to execute - filename, comment, platform
5. Plugins
  + Null
  + PjDump
    - which options in options handler it adds.
  + MySQL
    + Database modeling
    + arguments added to the options handler. (batches, server, etc.)
      
6. Performance Evaluation
  + Overview of what is being evaluated and why (my sql is the only NEW feature)
  + Methodology
  + Results and grafics
  + Possible explanations
7. Conclusion

* 2016-03-17 Meeting with Tais (TCC Registration)                :Lucas:Tais:

_Title_

Extensible Simulator for Trace Replay

_Abstract_

Observation of program behavior is particularly important in High
Performance Computing since it enables a performance analysis. Tracing
is a very common method to do so, where interesting program events are
registered in trace files. Replaying these trace files through
simulation is used to analyze the data. The idea of simulation is to
combine information that is spread in multiple events deriving new and
richer combined entities. Usually, this event processing is done once
and discarded, an approach adopted, for instance, by the Paje trace
simulator. Since today trace files can be very large, it would be
interesting to save these entities for future analysis. The objective
of this proposal is to allow the performance analyst to change the
simulator behavior when entities are detected. This extensibility
should be implemented through plugins, that could be developed by
anyone. The methodology to implement this objective is to develop a
extensible simulator where every time an entity is created, it would
direct that information to a plugin. It will be the plugin's
reponsability to handle the entity. As a proof of concept, this work
will propose the implementation of two plugins: a textual output
similar to Paje's =pj_dump=; and an efficient database insertion in a
pre-defined relational schema. A performance evaluation will be
conducted to compare the trace simulator against other existing
similar approaches.

_Side Note_
- Change way variables are stored in tables
  - Each entry (value) of one given variable must have start and end time
- Two meetings are expected
  - Performance analysis of the implementation
  - TCC organization (script/plan)
- How to save in Emacs (C-x C-s)
  - Copy: Select with the mouse or keyboard and then M-w
  - Past: C-y


* 2016-04-20 TCC Structure                                       :Lucas:Tais:

1. Introduction
   - Overview/Context
     - Observation of program behavior is particularly important in
       High Performance Computing since it enables a performance
       analysis. Tracing is a very common method to do so, where
       interesting program events are registered in trace
       files. Replaying these trace files through simulation is used
       to analyze the data. The idea of simulation is to combine
       information that is spread in multiple events deriving new and
       richer combined entities. Usually, this event processing is
       done once and discarded, an approach adopted, for instance, by
       the Paje trace simulator. Since today trace files can be very
       large, it would be interesting to save these entities for
       future analysis.
   - Specific Context
     - About Paje, how it works, ...
       - Who use it: SimGrid, StarPU, 
     - How does it work?
   - Problem identification
     - There are at least three problems with the current
       implementaton of Paje: 1, 2 and 3.
     - It is very complicated to change the Paje simulator behavior,
       since it requires code modifications in the simulator core and
       understand code details.
     - The simulator creates the entities according to the events, but
       the user needs to wait the end of simulation to access the
       data. You cannot have a partial view of already simulated data.
     - Last, once the simulator finished, all the simulation effort is
       lost since no record of the simulated entities are kept between
       executions.
   - Objective
     - The objective of this proposal is to allow the performance
       analyst to change the simulator behavior when entities are
       detected. This extensibility can be implemented through plugins
       that can be attached to the simulator in specific and important
       points where trace events are combined. This main objective
       solves the first problem previously presented, about the
       extensability of the simulator. Secondary objectives are the
       creation of plugins to dump partial simulated data and to make
       simulated data permanent. Finally, do a performance analysis to
       compare against the previous implementation of the paje simulator.
   - Main Results
     - We have implemented two plugins: one for data insertion in a
       DB, another to dump to standard output partial simulated data.
     - Highlight the main performance analysis results.
2. Basic Concepts? (5 pages max)
   + JavaCC? their flex
     - Introduction
     - How does it work (.jj -> .java -> .class)
     - .jj has a grammar, you can define a grammar the same way you do
       in bison/yacc
     - Other alternatives to javacc
       - ANTLR, but it is too slow (maybe show a plot comparing both
         if you have time)
   + R and Experimental Design
     - What is an experimental design?
     - Full factorial design!
     - Jain 1991
     - R to develop the factorial design
   + MySQL ?
     - 
3. PajeNG and the Paje File Format (3 to 4 pages, finish with a motivation to your own work)
   - Paje File Format
   - Overview
     - Container
     - State
     - Variables
     - Links
     - Events
     - Container has all others
   - Definition of events
   - Type hierarchy 
   - Events
     - Container
     - State
     - Event
     - Variable
     - Link 
   - PajeNG
     + How it is used by others (pjdump, etc)
       - In SimGrid, trace is in Paje file format, but all people use
         the CSV (the result of Paje simulation obtained through
         pjdump)
     + Description of how it works internally
       - It is a library with three main components
         - FileReader
         - EventDecoder
         - PajeSimulator
       - Works as a pipeline
         - See http://paje.sf.net/
           - Pajé, an interactive visualization tool for tuning multi-threaded parallel applications.
             A. Chassin de Kergommeaux, B. de Oliveira Stein, and Bernard P.E.
             Parallel Computing, 26(10):1253–1274, aug 2000.
           - See in particular the Fig. 7

     + _The problems with the current approach_
       - There are at least three problems with the current
         implementaton of Paje: 1, 2 and 3.
       - It is very complicated to change the Paje simulator behavior,
         since it requires code modifications in the simulator core and
         understand code details.
       - The simulator creates the entities according to the events, but
         the user needs to wait the end of simulation to access the
         data. You cannot have a partial view of already simulated data.
       - Last, once the simulator finished, all the simulation effort is
         lost since no record of the simulated entities are kept between
         executions.
     + Differences against your own contribution
       - My contribution is detailed in the next two chapters
4. Our Approach: a Java-based Simulator
   - Start with an overview
     - Figure showing all your components

   - Instrumentation points
     + The instrumentation points where plugins can be attached to
     - Describe each instrumentation point
       - The information that is passed along
       - Justify the presence of each information
     - Make reference to the overview figure
     - Figure
       - Has the simulator core (the component)
         - All the points

   - JavaCC Parsing and Paje File format grammar
     - Explain the grammar in yacc/bison terminology
       - Non-terminals, terminals..., tokens
     - Top-down parsing... or bottom-up?
     - Explain the process of transforming the grammar to java code

   - Simulator core
     - Follows the same structure of PajeNG
       - Simulator and Container (where simulation happens)
       - Use stack to simulate states
     - What are the _technical_ differences against PajeNG

   Next chapter details the implementation of the two plugins.

5. Plugins

The methodology to implement this objective is to develop a
extensible simulator where every time an entity is created, it would
direct that information to a plugin. It will be the plugin's
reponsability to handle the entity. As a proof of concept, this work
will propose the implementation of two plugins: a textual output
similar to Paje's =pj_dump=; and an efficient database insertion in a
pre-defined relational schema. A performance evaluation will be
conducted to compare the trace simulator against other existing
similar approaches.

   + Null
   + PjDump
   + MySQL
     + Database modeling
     + arguments (batches, server, etc.)

6. Performance Evaluation
   + Overview of what is being evaluated and why (mysql is the only NEW feature)
   + Experimental Methodology
     - Full factorial
   + Results and grafics
   + Possible explanations
   + 

7. Conclusion
   - All efforts in the simulator optimization benefit all plugins.
   - Future work
     - Perf. Eval. in Windows

Appendix
- How to implement a plugin?

* References

** 23/04

https://dzone.com/articles/antlr-and-javacc-parser-generators
https://javacc.java.net/
http://www.computing.dcu.ie/~hamilton/teaching/CA448/notes/JavaCClex2.pdf

** 24/04
http://eriklievaart.com/blog/javacc2.html
http://paje.sourceforge.net/download/publication/lang-paje.pdf

** 26/04

http://www.jmp.com/support/help/Full_Factorial_Designs.shtml
https://cran.r-project.org/web/packages/DoE.base/DoE.base.pdf

https://github.com/schnorr/pajeng/wiki/pj_dump

http://simgrid.gforge.inria.fr/tutorials/simgrid-tracing-101.pdf
http://simgrid.gforge.inria.fr/




* 
Other points:
- use the \label command in each chapter to mark (I give you an
  example in basic concepts chapter below)
- use the \ref to make reference to a chapter/section, such as
  \ref{chapter.basic_concepts}. This provides you a cleaner way to
  reference things, such as figures, tables, sections, whatever.
- you need to cite the documents you reference, and still cite related
  work that support your motivation. I'll give you an example of that
  asap, using bibtex.


(Write about the current extensibility of Paje original and next
generation. Say that is not enough for current needs because writing
a full component for Paje is a complex thing - one needs to know the
protocol, the internal objects and class hierarchy and so on. Very few
people have done so.)

It is very complicated to change the Paje simulator behavior,
since it requires code modifications in the simulator core, which
depends upon understanding details of the program. If a performance
analyst wants to evaluate only one type of entity, or needs a
different presentation of the data, he will need to have at least a
basic understanding of how the program is implemented in order to
generate these different results. 

* Notes 

Importance of implementtion of plugins, to validade and to see flaws,
such as which objects to send to the plugin. 
